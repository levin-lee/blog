<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>常见机器学习优缺点</title>
    <url>/2020/05/01/%E5%B8%B8%E8%A7%81%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%BC%98%E7%BC%BA%E7%82%B9/</url>
    <content><![CDATA[<h1 id="1、线性回归："><a href="#1、线性回归：" class="headerlink" title="1、线性回归："></a>1、线性回归：</h1><p>线性回归的基本假设：1、模型对参数是线性的；2、严格外生性：既解释变量x与随机误差项\segma不相关；3、无多重共线性，既解释变量间没有完全线性关系，或者x.T*x是非奇异的；条件同方差：误差项的均值为0，方差为\segma^2；任意两点的误差项不自相关 。   解释变量的联合显著性：F检验  异方差检验：white检验</p>
<a id="more"></a>
<h1 id="2、-logistic回归"><a href="#2、-logistic回归" class="headerlink" title="2、 logistic回归"></a>2、 logistic回归</h1><p>基础思想：logistic回归属于对数线性模型，是一种分类算法。Logistic在输出值上施加sigmoid函数将值收敛到0~1范围。logitisc中y是一个定型变量，比如y=0或1，logistic方法主要应用于研究某些事件发生的概率，广泛运用于评分卡模型。优点 ：1）速度快，适合二分类问题；2）简单易于理解，直接看到各个特征的权重；3）能容易地更新模型吸收新的数据。缺点：对数据和场景的适应能力有局限，不如决策树算法适应性那么强。容易欠拟合。</p>
<h1 id="3、朴素贝叶斯"><a href="#3、朴素贝叶斯" class="headerlink" title="3、朴素贝叶斯"></a>3、朴素贝叶斯</h1><p>1)基础思想：对于给出的待分类项，求解在此项出现的条件下各个类别出现的概率，哪个最大，就认为此分类项属于哪个类别。最大化后验概率   2)优点：方法简单，分类准确率高，速度快，所需估计的参数少，对于缺失数据不敏感。3)缺点：假设样本特征彼此独立，这往往并不成立。(喜欢吃番茄、鸡蛋，却不喜欢吃番茄炒蛋)。需要知道先验概率。</p>
<h1 id="4、SVM"><a href="#4、SVM" class="headerlink" title="4、SVM"></a>4、SVM</h1><p>支持向量机是一种二分类模型，它的基本模型是定义在特征空间上的间隔最大的线性分类器。<br>1）基础思想：支持向量机把分类问题转化为寻找分类平面的问题，并通过最大化分类边界点距离分类平面的距离来实现分类。2）优点 ：可以解决小样本下机器学习的问题；提高泛化性能；可以解决文本分类、文字识别、图像分类等方面仍受欢迎；避免神经网络结构选择和局部极小的问题。3）缺点：缺失数据敏感；内存消耗大，难以解释。<br>多项式核  拉普拉斯核  Sigmoid核等</p>
<h1 id="5、决策树"><a href="#5、决策树" class="headerlink" title="5、决策树"></a>5、决策树</h1><p>1)基础思想：决策树是一种简单但广泛使用的分类器，它通过训练数据构建决策树，对未知的数据进行分类。决策树的每个内部节点表示在一个属性上的测试，每个分枝代表该测试的一个输出，而每个叶结点存放着一个类标号。在决策树算法中，ID3基于信息增益作为属性选择的度量，C4.5基于信息增益比作为属性选择的度量，CART基于基尼指数作为属性选择的度量。<br>2)优点 ：不需要任何领域知识或参数假设；适合高维数据；简单易于理解；短时间内处理大量数据，得到可行且效果较好的结果；  3)缺点：对于各类别样本数量不一致数据，信息增益偏向于那些具有更多数值的特征。易于过拟合。忽略属性之间的相关性。</p>
<h1 id="6、随机森林"><a href="#6、随机森林" class="headerlink" title="6、随机森林"></a>6、随机森林</h1><p>随机森林实际上是一种特殊的bagging方法，它将决策树用作bagging中的模型。首先，生成m个训练集，然后，对于每个训练集，构造一颗决策树，在节点找特征进行分裂的时候，并不是对所有特征找到能使得指标（如信息增益）最大的，而是在特征中随机抽取一部分特征，在抽到的特征中间找到最优解，应用于节点，进行分裂。随机森林的方法由于有了bagging，也就是集成的思想在，实际上相当于对于样本和特征都进行了采样（如果把训练数据看成矩阵，就像实际中常见的那样，那么就是一个行和列都进行采样的过程），所以可以避免过拟合。2）优点：它能够处理很高维度的数据，并且不用做特征选择(因为特征子集是随机选择的)；无偏估计，模型泛化能力强；训练速度快，容易做成并行化方法；对于不平衡的数据集来说，它可以平衡误差。 3）缺点：随机森林已经被证明在某些噪音较大的分类或回归问题上会过拟 ；对于有不同取值的属性的数据，取值划分较多的属性会对随机森林产生更大的影响，所以随机森林在这种数据上产出的属性权值是不可信的。</p>
<h1 id="7、GBDT"><a href="#7、GBDT" class="headerlink" title="7、GBDT"></a>7、GBDT</h1><p>1）GBDT算法是模型为加法模型，学习算法为前向分步算法，基函数为CART树，损失函数为平方损失函数的回归问题。每次迭代中拟合残差来学习一个弱学习器。而残差的方向即为我们全局最优的方向。损失函数负梯度的方向代替残差方向，我们称损失函数负梯度为伪残差。而伪残差的方向即为我们局部最优的方向。所以在GBDT中，当损失函数不为平方损失时，用每次迭代的局部最优方向代替全局最优方向 2）优点：可以灵活处理各种类型的数据，包括连续值和离散值；在相对少的调参时间情况下，预测的准备率也可以比较高。这个是相对SVM来说的；使用一些健壮的损失函数，对异常值的鲁棒性非常强。比如 Huber损失函数和Quantile损失函数；很好的利用了弱分类器进行级联；充分考虑的每个分类器的权重。3）缺点：由于弱学习器之间存在依赖关系，难以并行训练数据。不过可以通过自采样的SGBT来达到部分并行。</p>
<h1 id="8、GBDT和随机森林的区别"><a href="#8、GBDT和随机森林的区别" class="headerlink" title="8、GBDT和随机森林的区别"></a>8、GBDT和随机森林的区别</h1><p>1）相同点：都是由多棵树组成；最终的结果都由多棵树共同决定。2）不同点：a 组成随机森林的树可以分类树也可以是回归树，而GBDT只由回归树组成；b 组成随机森林的树可以并行生成；GBDT 只能串行生成；c 随机森林的结果是多数表决表决的，而GBDT则是多棵树加权累加之和；d 随机森林对异常值不敏感，而GBDT对异常值比较敏感；e 随机森林是减少模型的方差，而GBDT是减少模型的偏差；f 随机森林不需要进行特征归一化。而GBDT则需要进行特征归一化；g 随机森林对训练集一视同仁权值一样，GBDT是基于权值的弱分类器的集成</p>
<h1 id="9、GBDT与Xgboost的区别"><a href="#9、GBDT与Xgboost的区别" class="headerlink" title="9、GBDT与Xgboost的区别"></a>9、GBDT与Xgboost的区别</h1><p>1）传统GBDT以CART作为基分类器，xgboost还支持线性分类器，这个时候xgboost相当于带L1和L2正则化项的逻辑斯蒂回归（分类问题）或者线性回归（回归问题）。2）传统GBDT在优化时只用到一阶导数信息，xgboost则对代价函数进行了二阶泰勒展开，同时用到了一阶和二阶导数。3）xgboost在代价函数里加入了正则项，用于控制模型的复杂度。4）列抽样（column subsampling）。xgboost借鉴了随机森林的做法，支持列抽样，不仅能降低过拟合，还能减少计算。5）对缺失值的处理。对于特征的值有缺失的样本，xgboost可以自动学习出它的分裂方向。6）xgboost工具支持并行。</p>
<h1 id="10、bagging和boosting的区别"><a href="#10、bagging和boosting的区别" class="headerlink" title="10、bagging和boosting的区别"></a>10、bagging和boosting的区别</h1><p>1）样本选择上：Bagging：训练集是在原始集中有放回选取的，从原始集中选出的各轮训练集之间是独立的。<br>Boosting：每一轮的训练集不变，只是训练集中每个样例在分类器中的权重发生变化。而权值是根据上一轮的分类结果进行调整。   2）样例权重：Bagging：使用均匀取样，每个样例的权重相等；Boosting：根据错误率不断调整样例的权值，错误率越大则权重越大。  3）预测函数：Bagging：所有预测函数的权重相等。Boosting：每个弱分类器都有相应的权重，对于分类误差小的分类器会有更大的权重。 4）并行计算：Bagging：各个预测函数可以并行生成；Boosting：各个预测函数只能顺序生成，因为后一个模型参数需要前一轮模型的结果。 5）bagging是减少variance，子模型有一定的相关性；而boosting是减少bias，forward-stagewise这种贪心法去最小化损失函数</p>
<h1 id="11、聚类"><a href="#11、聚类" class="headerlink" title="11、聚类"></a>11、聚类</h1><h2 id="k-means原理："><a href="#k-means原理：" class="headerlink" title="k-means原理："></a>k-means原理：</h2><p>K均值算法比较简单。首先，选择K个初始质心，其中K是用户指定的参数，既所期望的族的个数。每个点指派到最近的质心，而指派到一个质心的点集为一个族。然后，根据指派到族的点，更新每个族的质心。重复指派和更新步骤，直到族不发生变化，或等价地，直到质心不发生变化。  最小化每个点到最近质心的距离的平方，也可以用均值作为质心）  改进：二分K均值   2）优点: 原理简单，实现方便，收敛速度快; 聚类效果较优；模型的可解释性较强；调参只需要簇数k；3）缺点：k的选取不好把握；对于不是凸的数据集比较难以收敛；如果数据的类型不平衡，比如数据量严重失衡或者类别的方差不同，则聚类效果不佳；采用的是迭代的方法，只能得到局部最优解；对于噪音和异常点比较敏感。</p>
<h2 id="层次聚类："><a href="#层次聚类：" class="headerlink" title="层次聚类："></a>层次聚类：</h2><p>从点作为个体族开始，每一步合并两个最接近的族，直到只剩下一个族。定义族之间的邻近性： MIN：族的邻近点为不同族的两个最近的点之间邻近度；MAX：不同族中两个最远的点之间的邻近度作为族的邻近度；组平均：取自不同族的所有点对邻近度的平均值</p>
<h2 id="密度聚类："><a href="#密度聚类：" class="headerlink" title="密度聚类："></a>密度聚类：</h2><p>优点：相对抗噪声，并且能够处理任意形状和大小的族。能克服基于距离的算法只能发现‘类圆形’的聚类的缺点。缺点：族的密度变化太大，或者高维数组，不够精确。</p>
<h1 id="12、PCA"><a href="#12、PCA" class="headerlink" title="12、PCA"></a>12、PCA</h1><p>即主成分分析方法，是一种使用最广泛的数据降维算法。PCA的主要思想是将n维特征映射到k维上，这k维是全新的正交特征也被称为主成分，是在原有n维特征的基础上重新构造出来的k维特征。PCA的工作就是从原始的空间中顺序地找一组相互正交的坐标轴，新的坐标轴的选择与数据本身是密切相关的。其中，第一个新坐标轴选择是原始数据中方差最大的方向，第二个新坐标轴选取是与第一个坐标轴正交的平面中使得方差最大的，第三个轴是与第1,2个轴正交的平面中方差最大的。依次类推，可以得到n个这样的坐标轴。</p>
<h1 id="13、过拟合和欠拟合"><a href="#13、过拟合和欠拟合" class="headerlink" title="13、过拟合和欠拟合"></a>13、过拟合和欠拟合</h1><p>过拟合：训练出来的模型过拟合了训练集, 对训练集外的数据却预测不准, 这称泛化性能不好。解决方法：1）正则化；2）增加数据量；3）减少模型特征，降低模型复杂度；4）减少训练次数。欠拟合：1）增加数据量；2）增加衍生特征，增加模型复杂度；</p>
<h1 id="14、SVM-和-LR-的区别"><a href="#14、SVM-和-LR-的区别" class="headerlink" title="14、SVM 和 LR 的区别"></a>14、SVM 和 LR 的区别</h1><p>相同点：1）都是线性分类器。本质上都是求一个最佳分类超平面；2）都是监督学习算法。  不同点：本质上是损失函数不同，LR的损失函数是交叉熵：SVM荷叶损失函数；2）两个模型对数据和参数的敏感程度不同 3） SVM 基于距离分类，LR 基于概率分类。 </p>
<h1 id="15、模型评估"><a href="#15、模型评估" class="headerlink" title="15、模型评估"></a>15、模型评估</h1><p>KS：KS用于模型风险区分能力进行评估， 指标衡量的是好坏样本累计分部之间的差值。好坏样本累计差异越大，KS指标越大，那么模型的风险区分能力越强；<br>Precision：是指在所有系统判定的“真”的样本中，确实是真的的占比； = 1-假真率；<br>Recall：是指在所有确实为真的样本中，被判为的“真”的占比    = 真正率；<br>ROC曲线：横坐标为False Positive Rate(FPR假正率)，纵坐标为True Positive Rate(TPR真正率)；<br>AUC：ROC曲线下的面积，通常大于0.5，小于1；</p>
<h1 id="16、主成分分析（PCA）与因子分析的区别"><a href="#16、主成分分析（PCA）与因子分析的区别" class="headerlink" title="16、主成分分析（PCA）与因子分析的区别"></a>16、主成分分析（PCA）与因子分析的区别</h1><ul>
<li>主成分分析是通过变量变换把注意力集中在具有较大方差的那些主成分上，而舍弃那些方差小的主成分；因子分析是因子模型把注意力集中在少数不可观测的潜在变量（即公共因子）上，而舍弃特殊因子。</li>
<li>主成分分析是将主成分表示为原观测变量的线性组合， 因子分析则是对原观测变量分解成公共因子和特殊因子两部分</li>
<li>主成分的各系数w，是唯一确定的、正交的。不可以对系数矩阵进行任何的旋转，且系数大小并不代表原变量与主成分的相关程度；而因子模型的系数矩阵是不唯一的、可以进行旋转的，且该矩阵表明了原变量和公共因子的相关程度。</li>
<li>主成分分析，可以通过可观测的原变量X直接求得主成分Y，并具有可逆性；因子分析中的载荷矩阵是不可逆的，只能通过可观测的原变量去估计不可观测的公共因 子，即公共因子得分的估计值等于因子得分系数矩阵与原观测变量标准化后的矩阵相乘的结果。还有，主成分分析不可以像因子分析那样进行因子旋转处理。</li>
<li>综合排名。主成分分析一般依据第一主成分的得分排名，若第一主成分不能完全代替原始变量，则需要继续选择第二个主成分、第三个等等，此时综合得分=∑ （各主成分得分×各主成分所对应的方差贡献率）,主成分得分是将原始变量的标准化值，代入主成分表达式中计算得到；而因子分析的综合得分=∑（各因子得分 ×各因子所对应的方差贡献率）÷∑各因子的方差贡献率，因子得分是将原始变量的标准化值，代入因子得分函数中计算得到。</li>
</ul>
]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive操作</title>
    <url>/2020/04/18/Hive%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="1、小表join大表原则；"><a href="#1、小表join大表原则；" class="headerlink" title="1、小表join大表原则；"></a>1、小表join大表原则；</h1><p>Hive中的常用基本数据类型：<br>|数据类型 | 长度 | 备注|<br>|—-|—-|—-|<br>| Tinyint | 1字节的有符号整数 | -128~127 |<br>| SmallInt | 1个字节的有符号整数 | -32768~32767 |<br>| Int | 4个字节的有符号整数 | -2147483648 ~ 2147483647 |<br>| BigInt | 8个字节的有符号整数 | |<br>| Boolean | 布尔类型，true或者false true、false | |<br>| Float | 单精度浮点数 | |<br>| Double | 双精度浮点数 | |<br>| String | 字符串 | |<br>| TimeStamp | 整数 | 支持Unix timestamp，可以达到纳秒精度 |<br>| Binary | 字节数组  | |<br>| Date | 日期 | 0000-01-01 ~ 9999-12-31，常用String代替 |<br><a id="more"></a></p>
<h1 id="2、具体语法"><a href="#2、具体语法" class="headerlink" title="2、具体语法"></a>2、具体语法</h1><p>创建数据库例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive&gt; create database if not exists user_db;</span><br></pre></td></tr></table></figure><br>查看数据库定义：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive&gt; describe database user_db;</span><br></pre></td></tr></table></figure><br>查看数据库列表：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive&gt; show databases;</span><br></pre></td></tr></table></figure><br>删除数据库：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive&gt; drop database if exists testdb cascade;</span><br></pre></td></tr></table></figure><br>切换当前数据库：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive&gt; use user_db;</span><br></pre></td></tr></table></figure></p>
<p>创建普通表：<br>1)第一种<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive&gt; create table if not exists userinfo  </span><br><span class="line">    (</span><br><span class="line">    userid int,</span><br><span class="line">    username string,</span><br><span class="line">    cityid int,</span><br><span class="line">    createtime date    </span><br><span class="line">    )</span><br><span class="line">    row format delimited fields terminated by &#39;\t&#39;</span><br><span class="line">    stored as textfile;</span><br></pre></td></tr></table></figure><br>row format delimited fields terminated by ‘\t’ 是指定列之间的分隔符；stored as textfile是指定文件存储格式为textfile。</p>
<p>2）第二种<br>create table as select 方式：根据查询的结果自动创建表，并将查询结果数据插入新建的表中。</p>
<p>3）第三种<br>create table like tablename1 方式：是克隆表，只复制tablename1表的结构。复制表和克隆表会在下面的Hive数据管理部分详细讲解。</p>
<p>创建外部表：<br>外部表是没有被hive完全控制的表，当表删除后，数据不会被删除。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive&gt; create external table iislog_ext (</span><br><span class="line">    ip string,</span><br><span class="line">    logtime string    </span><br><span class="line">    );</span><br></pre></td></tr></table></figure></p>
<p>创建分区表：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table user_action_log</span><br><span class="line">(</span><br><span class="line">companyId INT comment   &#39;公司ID&#39;,</span><br><span class="line">userid INT comment   &#39;销售ID&#39;,</span><br><span class="line">originalstring STRING comment   &#39;url&#39;, </span><br><span class="line">)</span><br><span class="line">partitioned by (dt string)</span><br><span class="line">row format delimited fields terminated by &#39;,&#39;</span><br><span class="line">stored as textfile;</span><br></pre></td></tr></table></figure></p>
<p>创建桶表：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table user_leads</span><br><span class="line">(</span><br><span class="line">leads_id string,</span><br><span class="line">user_id string,</span><br><span class="line">user_id string,</span><br><span class="line">user_phone string,</span><br><span class="line">user_name string,</span><br><span class="line">create_time string</span><br><span class="line">)</span><br><span class="line">clustered by (user_id) sorted by(leads_id) into 10 buckets </span><br><span class="line">row format delimited fields terminated by &#39;\t&#39; </span><br><span class="line">stored as textfile;</span><br></pre></td></tr></table></figure></p>
<p>查看简单定义：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">describe userinfo;</span><br></pre></td></tr></table></figure></p>
<p>查看表详细信息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">describe formatted userinfo;</span><br></pre></td></tr></table></figure></p>
<p>修改表名：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table userinfo rename to user_info;</span><br></pre></td></tr></table></figure></p>
<p>添加字段：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table user_info add columns (provinceid int );</span><br></pre></td></tr></table></figure></p>
<p>修改字段：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table user_info replace columns (userid int,username string,cityid int,joindate date,provinceid int);</span><br></pre></td></tr></table></figure></p>
<p>将本地文本文件内容批量加载到Hive表中：<br>——要求文本文件中的格式和Hive表的定义一致<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">load data local inpath &#39;&#x2F;home&#x2F;hadoop&#x2F;userinfodata.txt&#39; overwrite into table user_info;</span><br></pre></td></tr></table></figure></p>
<p>加载到分区表：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">load data local inpath &#39;&#x2F;home&#x2F;hadoop&#x2F;actionlog.txt&#39; overwrite into table user_action_log PARTITION (dt&#x3D;&#39;2017-05-26’);</span><br></pre></td></tr></table></figure></p>
<p>导入分桶表：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set hive.enforce.bucketing &#x3D; true;</span><br><span class="line">insert overwrite table user_leads select * from  user_leads_tmp;</span><br></pre></td></tr></table></figure></p>
<p>导出数据：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert overwrite local directory &#39;&#x2F;home&#x2F;hadoop&#x2F;user_info.bak2016-08-22 &#39;</span><br><span class="line">select * from user_info;</span><br></pre></td></tr></table></figure></p>
<p>插入数据的表是分区表：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert overwrite table user_leads PARTITION (dt&#x3D;&#39;2017-05-26&#39;) </span><br><span class="line">select * from  user_leads_tmp;</span><br></pre></td></tr></table></figure></p>
<p>复制表：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table user_leads_bak</span><br><span class="line">row format delimited fields terminated by &#39;\t&#39;</span><br><span class="line">stored as textfile</span><br><span class="line">as</span><br><span class="line">select leads_id,user_id,&#39;2016-08-22&#39; as bakdate</span><br><span class="line">from user_leads</span><br><span class="line">where create_time&lt;&#39;2016-08-22’;</span><br></pre></td></tr></table></figure></p>
<p>克隆表：<br>——克隆表时会克隆源表的所有元数据信息，但是不会复制源表的数据<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table user_leads_like like  user_leads;</span><br></pre></td></tr></table></figure></p>
<h1 id="3、Where筛选："><a href="#3、Where筛选：" class="headerlink" title="3、Where筛选："></a>3、Where筛选：</h1><p>操作符 说明<br>A=B   A等于B就返回true，适用于各种基本类型<br>A&lt;=&gt;B   都为Null则返回True，其他和=一样<br>A&lt;&gt;B   不等于<br>A!=B   不等于<br>A<B 小于 a<="B" 小于等于 a>B   大于<br>A&gt;=B   大于等于<br>A Between B And C   筛选A的值处于B和C之间<br>A Not Between B And C   筛选A的值不处于B和C之间<br>A Is NULL   筛选A是NULL的<br>A Is Not NULL   筛选A值不是NULL的<br>A Link B   %一个或者多个字符_一个字符<br>A Not Like B   %一个或者多个字符_一个字符<br>A RLike B   正则匹配 </B></p>
<h1 id="4、排序："><a href="#4、排序：" class="headerlink" title="4、排序："></a>4、排序：</h1><p>Sort By：<br>——Hive中尽量不要用Order By，除非非常确定结果集很小<br>select * from user_leads sort by user_id</p>
<p>日期函数：</p>
<p>1、UNIX时间戳转日期函数：from_unixtime<br>转化UNIX时间戳（从1970-01-01 00:00:00 UTC到指定时间的秒数）到当前时区的时间格式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive&gt; select from_unixtime(1323308943,&#39;yyyyMMdd&#39;) from lxw_dual;</span><br></pre></td></tr></table></figure></p>
<p>2、日期时间转日期函数：to_date<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive&gt; select to_date(&#39;2011-12-08 10:03:01&#39;) from lxw_dual;</span><br></pre></td></tr></table></figure><br>3、日期转年\月\日函数：year——month——day<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive&gt; select year(&#39;2011-12-08 10:03:01&#39;) from lxw_dual;</span><br></pre></td></tr></table></figure><br>4、日期比较函数：datediff<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive&gt; select datediff(&#39;2012-12-08&#39;,&#39;2012-05-09&#39;) from lxw_dual;</span><br></pre></td></tr></table></figure></p>
<p>5、日期增加、减少函数：date_add/date_sub<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive&gt; select date_add(&#39;2012-12-08&#39;,10) from lxw_dual;</span><br></pre></td></tr></table></figure></p>
<h1 id="5、字符串函数："><a href="#5、字符串函数：" class="headerlink" title="5、字符串函数："></a>5、字符串函数：</h1><p>1、字符串反转函数：reverse<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive&gt; select reverse(abcedfg’) from lxw_dual;</span><br></pre></td></tr></table></figure></p>
<p>2、字符串连接函数：concat<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive&gt; select concat(‘abc’,&#39;def’,&#39;gh’) from lxw_dual;</span><br></pre></td></tr></table></figure></p>
<p>3、带分隔符连接函数：concat_ws<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive&gt; select concat_ws(&#39;,&#39;,&#39;abc&#39;,&#39;def&#39;,&#39;gh&#39;) from lxw_dual;</span><br></pre></td></tr></table></figure></p>
<p>4、字符串截取函数：substr、substring<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive&gt; select substr(&#39;abcde&#39;,3) from lxw_dual;</span><br></pre></td></tr></table></figure><br>返回字符串A从start位置到结尾的字符串</p>
<p>5、字符串转大写和小写：upper、ucase / lower、lcase<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select lcase(&#39;abSEd&#39;) from lxw_dual;</span><br></pre></td></tr></table></figure></p>
<p>6、去空格函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive&gt; select trim(&#39; abc &#39;) from lxw_dual;</span><br></pre></td></tr></table></figure></p>
<p>7、正则表达式替代函数：regexp_replcae<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive&gt; select regexp_replace(&#39;foobar&#39;, &#39;oo|ar&#39;, &#39;&#39;) from lxw_dual;</span><br></pre></td></tr></table></figure></p>
<p>8、json解析函数：get_json_object<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">get_json_object(string json_string, string path)</span><br></pre></td></tr></table></figure></p>
<p>9、分隔字符串函数：split<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive&gt; select split(&#39;abtcdtef&#39;,&#39;t&#39;) from lxw_dual;</span><br></pre></td></tr></table></figure><br>返回数组</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Hive</tag>
      </tags>
  </entry>
  <entry>
    <title>linux之shell</title>
    <url>/2020/04/18/linux%E4%B9%8Bshell/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$# 是传给脚本的参数个数</span><br><span class="line">$0 是脚本本身的名字</span><br><span class="line">$1 是传递给该shell脚本的第一个参数</span><br><span class="line">$2 是传递给该shell脚本的第二个参数</span><br><span class="line">$@ 是传给脚本的所有参数的列表</span><br><span class="line">$* 是以一个单字符串显示所有向脚本传递的参数，与位置变量不同，参数可超过9个</span><br><span class="line">$$ 是脚本运行的当前进程ID号</span><br><span class="line">$? 是显示最后命令的退出状态，0表示没有错误，其他表示有错误</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>1、if-then语句<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if test command</span><br><span class="line">then commands</span><br><span class="line">else commands</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p>test检测：<br>数字<br>n1 -eq n2     检查n1是否与n2相等<br>n1 -ge n2     检查n1是否大于或等于n2<br>n1 -gt n2     检查n1是否大于n2<br>n1 -le n2     检查n1是否小于或等于n2<br>n1 -lt n2     检查n1是否小于n2<br>n1 -ne n2     检查n1是否不等于n2</p>
<p>字符串<br>-n str1       检查str1的长度是否非0<br>-z str1       检查str1的长度是否为0</p>
<p>2、for循环<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for var in list do</span><br><span class="line">commands</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file&#x3D;“states”</span><br><span class="line">IFS&#x3D;$&#39;\n’   #能读空行的值</span><br><span class="line">for state in $(cat $file)</span><br><span class="line">do</span><br><span class="line">   echo &quot;Visit beautiful $state&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>跳出循环：break、continue</p>
<p>3、创建函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function name &#123; commands</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>高级函数<br>4、sed命令<br>Sed编辑器被称为流编辑器，与普通的交互式文本编辑器想法。<br>1）在命令行定义编辑器<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ Echo “this is a test” | sed ’s&#x2F;test&#x2F;big test’</span><br></pre></td></tr></table></figure><br>This is a big test<br>或者<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sed ’s&#x2F;dog&#x2F;cat&#x2F;‘ data.txt</span><br></pre></td></tr></table></figure><br>Sed编辑器并不会修改文本文件的数据</p>
<p>2）在命令行使用多个编辑器<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sed -e ’s&#x2F;brown&#x2F;green&#x2F;; s&#x2F;dog&#x2F;cat’ data.txt</span><br></pre></td></tr></table></figure><br> 必须要用；分割</p>
<p>3）从文件中读取编辑器命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sed -f script1.sed datat.txt</span><br></pre></td></tr></table></figure></p>
<p>4）写入文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sed ‘1,2w test.txt’ datat.txt</span><br></pre></td></tr></table></figure><br>将test.txt文件的前两行打印到data.txt文件中</p>
<p>5、awk命令</p>
<p>1）格式化输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk &#39;&#123;printf &quot;%-8s %-10s\n&quot;,$1,$4&#125;&#39; log.txt</span><br></pre></td></tr></table></figure></p>
<p>2）使用，分割<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk &#39;BEGIN&#123;FS&#x3D;&quot;,&quot;&#125; &#123;print $1,$2&#125;&#39;  log.txt</span><br></pre></td></tr></table></figure></p>
<p>3）条件语句<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk &#39;BEGIN &#123;</span><br><span class="line">    num &#x3D; 11; </span><br><span class="line">    if (num % 2 &#x3D;&#x3D; 0) printf &quot;%d 是偶数\n&quot;, num; </span><br><span class="line">    else printf &quot;%d 是奇数\n&quot;, num </span><br><span class="line">&#125;&#39;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈我的北漂</title>
    <url>/2020/04/17/%E8%B0%88%E8%B0%88%E6%88%91%E7%9A%84%E5%8C%97%E6%BC%82/</url>
    <content><![CDATA[<p>最初开通github是打算写点技术文章，现在更像是我的记事本，时不时也需要记录下我对生活的感悟。<br>谈到北漂，以前一直以为与我无关，是很虚无飘渺的东西，因为我的目标城市是深圳或者上海。没想到阴差阳错最终来到北京。从去年19年的7月开始，我正式开启了我的北漂之旅，再过两个月就整整一年了。在这里我挥洒汗水，耗费青春的光阴而碌碌无为，忙忙碌碌且无成长，我常痛恨这样的自己。<br><a id="more"></a></p>
<h1 id="工作篇"><a href="#工作篇" class="headerlink" title="-工作篇 -"></a>-工作篇 -</h1><p>我工作的地方是被誉为中国互联网届的摇篮村，名叫后场村。我居住的地方也是人均程序员密度最高的西二旗。和我一起居住的还有我的两个研究生同学，和一个同事。另外还有一个是我校友的同事，一共五个人同租，后来成为我校友的女朋友，那是后话了。刚开始工作的三个月中，确实我成长最快的时候，这里要实名感谢@彩旭对我的帮助，我要是有计算机的问题基本都去找他，他也乐意帮忙，在他的帮助下，我才能快速上手linux，这个博客也是在他的影响下而开通的。而在业务层面，@子鹏对我的帮助较大。总之，前三个月是成长最快的时候，后续的工作其实都是在重复工作，没有自己的想法，只是一味地执行领导交代的任务。刚来这家公司最让我不习惯的是，内部没有很明确对校招生的培养机制，前辈写分享文档的也很少，所以需要自己一点点去琢磨，我想要是部门有完善的培养机制，应该能让我更快地上手吧。还有一个让我比较诡异的事情是。内部的分享沟通会很少，每个小组都在埋头干自己的工作，小组之间比较少交流，而且甚至部分小组藏着掖着，不想让其他组知道自己所做的事情，其他小组也无从介入，以保证自己的一个项目的绝对领导地位。<br>其他方面，由于部门是风控部门，是整个信贷产品的核心。所以，接触的面会广一些，会进行跨部门协同。这一块，需要不断地扯皮，才能推动业务进展，不过这一块，我想其他公司也该差不多吧。<br>公司的问题之下，也同时暴露了我的问题了，在工作中很粗心，经常计算出错，对待工作比较散漫，效率低下。这一块还是需要不断地磨合自己，历练自己。</p>
<h1 id="生活篇"><a href="#生活篇" class="headerlink" title="-生活篇-"></a>-生活篇-</h1><p>前面谈到我们是5个人同租房子。正所谓有人的地方就有江湖，从一开始的其乐融融，一片欢声笑语，到最后充满矛盾，相见无言，前后不超过2个月。这一切的导火索就是其中两人相恋了，矛盾不可避免地出现了。比如，本来约好5个人一起吃饭和游玩的计划。因为这对恋人私下约会而泡汤；又如，处于热恋期的两人常常在客厅聊至凌晨两三点，我们受其困扰，辗转难眠。从一开始的时候，搭伙煮饭，到最后分为三个团体，时间协调也是矛盾重重，所幸，我基本只点外卖。到最后，我悟出了一个道理，千万别和情侣一起合租。</p>
<p>十一将至，各种生活工作都开始稳定，就出现了一件大事，由于我们是5人合租，其中有两间是隔断房。而正值十一期间，北京严查隔断出租屋，导致大量中介的隔断房被拆除，我们门口就贴着一张隔断房拆除的通知。当时我们5人的关系还算不错，不像现在这样撕破脸都无所畏惧。我们惶恐不已，要是隔断房被拆除，无法再找个房子可以5个人合租在一起。为此我们不断地和房东沟通和交流，甚至做好了重新找房的准备。后来虽然证明这种担心是徒劳的，但我们还是费了不少心血在这上面。不过，我想我以后应该不会再租隔断房了。</p>
<h1 id="个人篇"><a href="#个人篇" class="headerlink" title="-个人篇-"></a>-个人篇-</h1><p>生活总是充满了各种感悟，北漂将近一年，已打算背起行囊，重新出发。<br><img src="/2020/04/17/%E8%B0%88%E8%B0%88%E6%88%91%E7%9A%84%E5%8C%97%E6%BC%82/12013139.jpg" alt="附图"></p>
]]></content>
      <categories>
        <category>感悟</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>模型评估</title>
    <url>/2020/04/05/%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>评分卡</title>
    <url>/2020/04/05/%E8%AF%84%E5%88%86%E5%8D%A1/</url>
    <content><![CDATA[<p>评分卡又称A卡，在金融领域，尤其是银行利用最多的模型，经常运用到贷前准入环节。它具有可解释性，模型稳定等各种优势。<br><a id="more"></a><br>得到评分卡的步骤如下：<br>一、认清目标<br>我们的目标是预测用户为好人的概率，并将概率转换成打分形式。分数越高表示用户的资质越好。</p>
<p>二、数据清洗和数据加工<br>将我们的非结构数据转化成结构化数据，连续数据转离散数据，去除异常值，标准化处理（最大最小值；正态标准化等）；<br>分箱操作就是将连续数据转成离散数据的方法之一。分箱的优势为：1、排除异常值的影响，例如：年龄为200岁；2、可以防止模型过拟合；3、为模型引入非线性，提高表达能力<br>分箱方法：</p>
<ul>
<li>监督方法：卡方分箱法、IV最大化分箱法</li>
<li>无监督方法：k-means聚类、等频、等宽</li>
</ul>
<p>三、特征工程<br>得到相对多的特征变量，在得到IV值之前，需要进行WOE，即特征转换。<br>之后分别计算IV值（information value），计算IV值。<br>根据IV值大小排列，IV值越高代表单个变量的可解释性越高。<br>得到比较重要的特征，取前topN特征代入线性回归中。<br>IV&lt;=0.02，没有解释性<br>0.1&lt;=IV&lt;0.02，具有较弱的解释性<br>0.3&lt;=IV&lt;=0.1，具有较强的解释性<br>0.3&lt;=IV，具有极强的解释性<br>一般来说，IV大于0.1时候，特征就可以保留下来。</p>
<p>四、LR线性回归<br>普通线性回归为：y = \beta_1<em>x_1+\beta_2</em>x_2+…+\beta_n<em>x_n，而logistic回归是将普通线性回归映射到 [0,1] 范围内。<br>Logistic 函数为：f(x) = \frac{1}{1+e^-x}<br>假定P是用户为坏人的概率，则1-P是用户为好人的概率，P∈[0,1]。<br>P(y=1|x) = \frac{e^wx}{1+e^wx}  ….. (1)<br>P(y=0|x) = \frac{1}{1+e^wx}        ……(2)<br>则 ods = \frac{p}{1-p}，是坏人与好人的几率。令p=P(y=1|x)，则好人的概率为1-p<br>将公式1除以公式2可得，ln\frac{p}{1-p} = wx，令y= ln\frac{p}{1-p}<br>故 lny = w_1</em>x_1+w_2<em>x_2+…+w_n</em>x_n</p>
<p>目标函数（损失函数）：<br>这里我们利用极大似然估计来得到logistic回归的损失函数：<br>L = \prod{I=1}{N}p^y_i+(1-p)^(1-y_i) ，<br>则lnL<br>        =  \sum{I=1}{N}ylnp+(1-)yln(1-p)<br>        =  \sum{I=1}{N}yln\frac{p}{1-p}+ln(1-p)<br>        =  \sum{I=1}{N}ywx+ln(\frac{1}{1+e^wx})</p>
<p>如何使损失函数最小化，这个时候就需要利用坐标下降法，来得到各个特征系数的值。</p>
<p>五、得到评分卡<br>在第四步，我们得到坏人的概率之后，就需要将概率转换成我们所需要的分数。<br>在得到分数之前，我们需要定义三个参数：</p>
<ul>
<li>基准odds好坏比，即\frac{p}{1-p}</li>
<li>基准分数</li>
<li>PDO(points to Double the odds)：当odds增加两倍时，所减少的信用分<br>可以列式子：</li>
</ul>
<ol>
<li>Base_score = A - Bln(odds)</li>
<li>Base_score - PDO = A - Bln(2odds)<br>可以得到：A = base_score + frac{PDO}{ln(2)}*ln(odds)，B = frac{PDO}{ln(2)}<br>当我们希望信用分为600分时，对应的ods为1:50。当ods扩大为2:50时，信用分降低20分至580分(PDO=20)，可以求出AB的取值。<br>A=487.122 ，B=28.854<br>六、模型评估<br>详见《模型与策略评估》专栏。</li>
</ol>
<p>参考目录：<br>【1】《统计学习方法》-李航<br>【2】《机器学习》-周志华</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>LR</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基本操作指令</title>
    <url>/2020/04/05/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>一，注销，关机，重启<br>1、Logout 注销是登陆的相对操作，登陆系统后，若要离开系统，用户只要直接下达<br>logout 命令即可：<br>2、关机或重新启动的 shutdown 命令：<br>    －h 参数让系统立即关机<br>        shutdown –h now ← 要求系统立即关机；<br>        shutdown now ← 立刻关机；<br>        shutdown +5 ← 5 分钟后关机；<br>        shutdown 10:30 ← 在 10：30 时关机；<br>    －r 参数设置关机后重新启动<br>        shutdown -r now ← 立刻关闭系统并重启；<br>        shutdown -r 23:59 ← 指定在 23：59 时重启动；<br><a id="more"></a><br>3、重新启动计算机的 reboot 命令：<br>     -f 参数：不依正常的程序运行关机，直接关闭系统并重新启动计算机；<br>     -I 参数：在在重新启动之前关闭所有网络接口；<br>     虽然 reboot 命令有个参数可以使用，但是一般只需要单独运行 reboot 命令就可以了<br>二，文件与目录的操作<br>1、列出文件列表的 ls 命令<br>    ls：显示当前目录的内容；<br>    ls –a： 当运行 ls 命令时，并不会显示名称以“.”开头的文件。因此可加上“-a”参数指<br>定要列出这些文件；<br>    ls –s –S：以“-s”参数显示每个文件所有的空间，并以“-S”参数指定按所有占用空间的大<br>小排序；<br>    ls –l/usr/games：在 ls 命令后直接加上欲显示的目录路径，就会列出该目录的内容；<br>2、切换目录的 cd 命令<br>     cd tony ← 切换到当前目录下的 tony 子目录；<br>     cd .. ← 切换到上一层目录；<br>     cd / ← 切换到系统根目录；<br>     cd /usr/bin ← 切换到/usr/bin 目；<br>3、创建目录的 mkdir 命令<br>     mkdir tool：在目录下创建 tool 子目录<br>4、删除目录的 rmdir 命令<br>     rmdir tool ← 删除 tool 目录<br>5、复制文件的 cp 命令<br>     cp data1.txt data2.txt ← 将 data1.txt 复制成 data2.txt；<br>     cp data3.txt /tmp/data ← 将 data3 复制到/tmp/data 目录中；<br>    加入-v 参数可显示命令执行过程：<br>         cp zip.txt zip2.txt ← 一般状态下不会显示复制过程；<br>         cp –v zip.txt zip3.txt ← 以-v 显示复制过程；<br>    加入“-R”参数可同时复制目录下的所有文件及子目录：<br>         cp –v –R <em> backup ← 将所有文件（含子目录文件）复制到 backup 目录<br>6、删除文件或目录的 rm 命令<br>         rm myfile ← 删除指定的文件；<br>         rm </em> ← 删除当前目录中的所有文件；<br>    使用-f 参数时，rm 命令会直接删除文件，不再询问：<br>        rm –f <em>.txt ← 强迫删除文件；<br>    -r 也是一个相当常用的参数，使用此参数可同时删除指定目录下的所有文件及子目录<br>        rm –r data ← 删除 data 目录（含 data 目录下所有文件和子目录）；<br>        rm –r </em> ← 删除所有文件（含当前目录所有文件，所有子目录和子目录下的文件）<br>    使用-rf 参数，系统将直接删除该目录中所有的文件及子目录，不再询问。<br>         rm –rf tmp 强制删除 tmp 目录及该目录下所有文件及子目录；<br>7、让显示画面暂停的 more 命令<br>         ls –al more：当使用 ls 命令查看文件列表时，若文件太多则可以配合 more 命令使用；<br>         more data.txt： 单独使用 more 命令时，可用来显示文字文件的内容；<br>8、连接文件的 cat 命令<br>    cat命令可以显示文件的内容（经常和 more 命令搭配使用），或是将数个文件合并成一个文件<br>         cat preface.txt more：逐页显示 preface.txt 的内容；<br>         cat preface.txt &gt;&gt; outline.txt： preface.txt 附加到 outline.txt 文件之后；<br>         cat new.txt info.txt &gt;readme.txt：将 new.txt 和 info.txt 合并成 readme.txt 文件<br>    一次显示整个文件：<br>        cat filename<br>9、移动或更换文件，目录名称的 mv 命令<br>    mv（move）命令可以将文件及目录移动到另一个目录下面，或更换文件及目录的名称<br>        mv a.txt .. ← 将 a.txt 文件移到上层目录<br>        mv z1.txt z3.txt ← 将 z1.txt 改名成 z3.txt<br>         cd.. ← 切换到上一层目录<br>        mv backup.. ← backup 目录上移一层<br>10、显示当前所在目录的 pwd 命令<br>    pwd(print working directory)命令可显示用户当前所在的目录<br>11、查找文件的 locate 命令<br>    locate 命令可用来搜索包含指定条件字符串的文件或目录<br>         locate zh_CN 列出所有包含“zh_CN”字符串的文件和目录<br>12、搜索字符串得 grep 命令<br>    grep 命令可以搜索特定字符串来并显示出来<br>         grep text <em>.conf ← 搜索当前目录中扩展名为.conf 且包含“text”字符串；<br>        grep:amd.conf: ← 拒绝不符权限得操作；<br>        grep:diskcheck.conf: ← 拒绝不符权限得操作；<br>        grep:grub.conf ← 拒绝不符权限得操作；<br>        grep –s text </em>.conf：拒绝不符权限的操作之类的错误信息，可使用-s 参数消除<br>13、重导与管道<br>    “&gt;”可将结果输出到文件中，该文件原有的内容会被删除：“&gt;&gt;”则将结果附加到文件中，原文件内容不<br>会被清除<br>         ls –a&gt;dir.txt ← 将 ls –a 命令执行结果输出到 dir.txt 文件；<br>         cat data1.txt &gt;&gt; data2.txt ← 将 data1.txt 内容附加到 data2.txt 文件之后。<br>    通道(pipe)命令的符号是“ ”，可将某命令的结果输出给另一命令<br>         ls gerp conf ← 搜索并显示 ls 命令运行结果中包含有“conf”字符串；<br>         yes rm –r mydir：在删除文件或目录的时，可以利用 yes 命令重复输出“y”字符的特性，将结果传给 rm<br> 命令，如此即可避免重复输入“y”<br>14、Linux文件内容查看</p>
<ul>
<li>Cat 由第一行开始显示文件内容</li>
<li>Tac 从文件最后一行开始显示</li>
<li>Nl 显示的时候，顺道输出行号！</li>
<li>more一页一页的显示文件内容</li>
<li>less与more类似，但是比more更好的是，他可以往前翻页</li>
<li>head只看头几行</li>
<li>tail只看尾巴几行<br>三、打包、压缩与解压缩<br>1、打包文件的 tar 命令<br>tar 命令位于/bin 目录中，它能将用户所指定的文件或目录打包成一个文件<pre><code>  -c：创建一个新的 tar 文件；
   -v：显示运作过程信息；
   -f：在：指定文件名称；
   -z：调用 gzip 压缩命令执行压缩；
   -j：调用 bzip2 压缩命令执行压缩；
  -t：参看压缩文件内容；
  -x：解开 tar 文件
           tar cvf data.tar * ← 将目录下所有文件打包成 data.tar；
           tar cvf data.tar.gz * ← 将目录所有文件打包成 data.tar 再用 gzip 命令压缩；
           tar tvf data.tar * ← 查看 data.tar 文件中包括了哪些文件；
           tar xvf data.tar * ← 将 data.tar 解开
</code></pre>2、压缩与解压缩<br>  使用-z 参数来解开最常见的.tar.gz 文件：<pre><code>   tar –zxvf foo.tar.gz ←将文件解开至当前目录下
</code></pre>  使用-j 参数解开 tar.bz2 压缩文件：<pre><code>   tar –jxvf linux-2.4.20tar.bz2 ←将文件解开至当前目录下
</code></pre>   使用-Z 参数指定以 compress 命令压缩：<pre><code>   tar –cZvf prcture.tar.Z*.tif 将该目录下所有.tif 打包并命令压缩成.tar.Z文件
</code></pre>四：其他常用命令<br>1、修改密码的 passwd 命令<br>  passwd（password）命令可让用户变更密码<br>2、创建引导盘的 mkbootdisk 命令<br>  利用 mkbootdisk 命令创建一张新的引导盘：<pre><code>   mkbootdisk ‘uname -r
</code></pre>3、显示与设置时间的 date、clock 和 ntpdate 命令<br>  date 命令可以显示当前日期时间；<br>  clock 命令也可以显示出系统当前的日期与时间；<pre><code>   date 09091200 ← 将时间设定为 9 月 9 日 12 点 00 分；
   ntpdate stdtime.microsoft.com ← 与微软校时服务器校时；
   clock –w：这样下次启动时才会使用更改过的时间
</code></pre></li>
</ul>
<p>环境变量的查看</p>
<p>1、使用echo命令查看单个环境变量。例如：<br>echo $PATH<br>2、使用env查看所有环境变量。例如：<br>env<br>3、使用set查看所有本地定义的环境变量</p>
<p>杀死正在进行或已经是DEST状态的进程<br>        ps -aux：查看所有进程<br>        sudo kill PID：杀死相对应的PID号码<br>文件查看<br>使用wc命令 具体通过wc —help 可以查看。</p>
<ul>
<li>wc -l filename 就是查看文件里有多少行；</li>
<li>wc -w filename 看文件里有多少个word；</li>
<li>wc -L filename 文件里最长的那一行是多少个字。<br>wc命令<br>　　wc命令的功能为统计指定文件中的字节数、字数、行数, 并将统计结果显示输出。<br>　　语法：wc [选项] 文件…<br>　　wc同时也给出所有指定文件的总统计数。字是由空格字符区分开的最大字符串。该命令各选项含义如下：<br>　　- c 统计字节数。<br>　　- l 统计行数。<br>　　- w 统计字数。<br>　　这些选项可以组合使用。输出列的顺序和数目不受选项的顺序和数目的影响。总是按下述顺序显示并且每项最多一列。<br>　　行数、字数、字节数、文件名<br>　　如果命令行中没有文件名，则输出中不出现文件名。<br>　　例如：<br>　　$ wc - lcw file1 file2<br>　　4 33 file1<br>　　7 52 file2<br>　　11 11 85 total<pre><code>省略任选项-lcw，wc命令的执行结果与上面一样。
</code></pre>解压：<pre><code>  sudo tar -zxvf pip-6.0.8.tar.gz
  cd ~ 返回默认根目录
</code></pre>删除文件：<pre><code>  rm -f /var/log/httpd/access.log
</code></pre>删除文件夹：<pre><code>  rm -rf /var/log/httpd/access
</code></pre>查看指令：<pre><code>  1、date —help
  2、man date
</code></pre></li>
</ul>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>python高级编程</title>
    <url>/2020/04/02/python%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="1、filter函数-过滤"><a href="#1、filter函数-过滤" class="headerlink" title="1、filter函数-过滤"></a>1、filter函数-过滤</h1><p>可以查看下面的例子<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">-5</span>,<span class="number">3</span>,<span class="number">-7</span>,<span class="number">6</span>]</span><br><span class="line">after_filter = map(<span class="keyword">lambda</span> x:x**<span class="number">2</span>,filter(<span class="keyword">lambda</span> x:x&gt;<span class="number">0</span>,num))</span><br><span class="line">print(after_filter)</span><br></pre></td></tr></table></figure><br>当然，也可以用python自带的迭代器,可以达到一样的效果<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">after_filter = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> num <span class="keyword">if</span> x&gt;<span class="number">0</span>]</span><br></pre></td></tr></table></figure><br><a id="more"></a><br>此外，还可以使用生成器<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">squre_generator</span><span class="params">(parameter)</span>:</span></span><br><span class="line">    rerurn(x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> num <span class="keyword">if</span> x&gt;parameter)</span><br><span class="line">g = list(squre_generator(<span class="number">0</span>))</span><br></pre></td></tr></table></figure></p>
<h1 id="2、装饰器"><a href="#2、装饰器" class="headerlink" title="2、装饰器"></a>2、装饰器</h1><p>装饰器为我们提供了一个增加已有函数或类的功能。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timethis</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">   @wraps(func)</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">      start = time.time()</span><br><span class="line">      result = func(*args,**kwargs)</span><br><span class="line">      end = time.time()</span><br><span class="line">      print(func.__name__,end-start)</span><br><span class="line">      <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@timethis</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> n&gt;<span class="number">0</span>:</span><br><span class="line">    n-=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">countdown(<span class="number">10000</span>)</span><br></pre></td></tr></table></figure></p>
<h1 id="3、-和和xx-的区别"><a href="#3、-和和xx-的区别" class="headerlink" title="3、_和和xx__的区别"></a>3、_和<strong>和</strong>xx__的区别</h1><h2 id="1）“-”单下划线"><a href="#1）“-”单下划线" class="headerlink" title="1）“_”单下划线"></a>1）“_”单下划线</h2><p>可以在类的方法或属性前加一个“_”单下划线，意味着该方法或属性不应该去调用。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_method</span><span class="params">(self)</span>:</span> </span><br><span class="line">        print(<span class="string">'约定为不在类的外面直接调用这个方法，但是也可以调用’) </span></span><br><span class="line"><span class="string">    def method(self): </span></span><br><span class="line"><span class="string">        return self._method() </span></span><br><span class="line"><span class="string">a = A()</span></span><br></pre></td></tr></table></figure><br>在类A中定义了一个_method方法，按照约定是不能在类外面直接调用它的，为了可以在外面使用_method方法，又定义了method方法，method方法调用_method方法。请看代码演示：<br>a._method() 不建议在类的外面直接调用这个方法，但是也可以调用。最好是a.method()</p>
<h2 id="2）双”-”下划线"><a href="#2）双”-”下划线" class="headerlink" title="2）双”__”下划线"></a>2）双”__”下划线</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__method</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'This is a method from class A'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__method()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__method</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'This is a method from calss B'</span>)</span><br></pre></td></tr></table></figure>
<p>在类A中，<strong>method方法其实由于name mangling技术的原因，变成了_A</strong>method，所以在A中method方法返回的是_A<strong>method，B作为A的子类，只重写了</strong>method方法，并没有重写method方法，所以调用B中的method方法时，调用的还是_A<strong>method方法：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">27</span>]: a = A()</span><br><span class="line">In [<span class="number">28</span>]: b = B()</span><br><span class="line">In [<span class="number">29</span>]: a.method()</span><br><span class="line">This <span class="keyword">is</span> a method <span class="keyword">from</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"><span class="title">In</span> [30]:</span> b.method()</span><br><span class="line">This <span class="keyword">is</span> a method <span class="keyword">from</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br></pre></td></tr></table></figure><br>在A中没有</strong>method方法，有的只是_A__method方法，也可以在外面直接调用，所以python中没有真正的私有化</p>
<h2 id="3）“xx”前后各双下划线"><a href="#3）“xx”前后各双下划线" class="headerlink" title="3）“xx”前后各双下划线"></a>3）“<strong>xx</strong>”前后各双下划线</h2><p>在特殊的情况下，它只是python调用的hook。例如，<strong>init</strong>()函数是当对象被创建初始化时调用的;<strong>new</strong>()是用来创建实例。<br><strong>init</strong> #构造初始化函数,<strong>new</strong>之后运行<br><strong>new</strong> #创建实例所需的属性<br><strong>class</strong> #实例所在的类，实例.<strong>class</strong><br><strong>str</strong> #实例的字符串表示，可读性高<br><strong>repr</strong> #实例的字符串表示，准确性高<br><strong>del</strong> #删除实例引用<br><strong>dict</strong> #实力自定义属性，vars(实例.<strong>dict</strong>)<br><strong>doc</strong> #类文档，help(类或者实例)<br><strong>bases</strong> #当前类的所有父类<br><strong>getattribute</strong> #属性访问拦截器。</p>
<h1 id="4、map函数"><a href="#4、map函数" class="headerlink" title="4、map函数"></a>4、map函数</h1><p>map()函数接收两个参数，一个是函数，一个是序列，map将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">return</span> x * x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure></p>
<h1 id="5、reduce函数"><a href="#5、reduce函数" class="headerlink" title="5、reduce函数"></a>5、reduce函数</h1><p>reduce这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(x, y)</span>:</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">return</span> x * <span class="number">10</span> + y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(fn, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])</span><br><span class="line"><span class="number">13579</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>向左走，向右走</title>
    <url>/2020/03/30/%E5%90%91%E5%B7%A6%E8%B5%B0%EF%BC%8C%E5%90%91%E5%8F%B3%E8%B5%B0/</url>
    <content><![CDATA[<p>很喜欢台湾作家几米画的单行本漫画《向左走，向右走》，文字中处处透露着温暖，插画清新自然，很舒服。<br><a id="more"></a><br>书中描绘着，在一座陌生的城市中，寂寞孤独的一对男女因为偶然一次缘分在公园相遇，互诉衷肠，两个落寞的心彼此感受着对方的温暖。然而，天空开始下着暴雨，俩人不得不分开，在临别前女生给男生留下写着电话的字条，就各自匆忙回家。不幸的是，字条由于雨水打湿而模糊了字迹，辨认不出号码。女生就这么焦急地等待男生的电话，而男生由于打湿字条而懊悔，满怀希望去公园等待，每次只能失望而归。时间缓缓流逝，又回到当初孤生一人的状态，生活仿佛又恢复了平静，只有他们自己知道，他们的心结了厚厚一层霜。生活在同个城市，两人有很多次机会相遇，但一人习惯向左，一人习惯向右，总是插肩而过，仿佛命运给他们开了无情的玩笑，注定无法相遇。又过了一段时间，女生打算离开这个让她伤心的城市。女生早早起床，把行李收拾好，打算在日出来临之时逃离这座城市，恰好遇上同样外出的男生。这一次，命运开始重新眷顾他们，在最重要的时刻他们重新相遇，那一刻，初升的阳光温柔地打在他们身上，暖暖的，融化了心里的霜。<br><img src="/2020/03/30/%E5%90%91%E5%B7%A6%E8%B5%B0%EF%BC%8C%E5%90%91%E5%8F%B3%E8%B5%B0/left.jpg" alt="漫画图"><br>这本书其实带给我很深的感动。以前在学校，身边总是围绕着很多东西，心里不觉得孤单，但等我真正走出社会，我才发现，在这钢筋水泥包裹着的城市，心慢慢开始学会忍受孤独。慢慢地开始习惯一个人，习惯一个人吃饭、一个人逛街、一个人看电影，一个人学会忍受孤独，内心开始慢慢封闭，终于我们会发现原来一个人也会慢慢习惯。</p>
<p>本书带给我的另一个感受是，人的一生会错过许许多多的人，有的人你会跟他相识相知，然后一别再也不见；有的人仅仅是打一个照面，就再也没有出现在你的世界中。每一天我们都在上演这离别戏码，可能是你身边的爱人和家人，也有可能是司机、路人、乘客。每次离别时，我们总以为还有机会再见，下次会有勇气把“我喜欢你”说给心底的那人听，但往往离别之后，再也无法遇见，未说出口的表白成为永久的遗憾。</p>
<p>一别之后，两地相悬，怎知说那三四载，谁知是一生憾事。</p>
]]></content>
      <categories>
        <category>感悟</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title>高性能MySQL</title>
    <url>/2020/03/21/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/</url>
    <content><![CDATA[<p>浅谈高性能MySQL</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>投资的那些事</title>
    <url>/2020/03/15/%E6%8A%95%E8%B5%84/</url>
    <content><![CDATA[<p>人的一生都是不断投资自己的一个过程，投资是一辈子的事情，任何人都应该去学会投资。这里的投资并不是狭隘地指投资股票、债券等二级市场的行为，它也可以掌握理财或者更单纯地投资自己，花费时间看我一本书是投资、投入精力学习一项新技术也是投资。对于投资，我有几点想法，可以和大家一起交流。</p>
<a id="more"></a>
<h2 id="1、任何时候，投资的首要目标都是先投资自己"><a href="#1、任何时候，投资的首要目标都是先投资自己" class="headerlink" title="1、任何时候，投资的首要目标都是先投资自己"></a>1、任何时候，投资的首要目标都是先投资自己</h2><p>为什么投资的首要目标是投资自己？不要认为投资都是将钱投到金融市场中，投资自己比其他任何投资都更有意义。那么该如何正确投资自己，每天保持不断学习，付出时间和精力，每天坚持看几本书，培养自己的兴趣爱好，和喜欢的人交谈，花钱培养一项新技能，这些都是可以让你受益匪浅的投资，将会伴随你的一生。任何适合，投资自己永远是一项正确的决定。投资自己，永远不要怕多晚。</p>
<h2 id="2、不断学习、努力工作"><a href="#2、不断学习、努力工作" class="headerlink" title="2、不断学习、努力工作"></a>2、不断学习、努力工作</h2><p>学习是最有价值的一项投资，这是一条准则。古今中外，莫不如是。不会学习的人，只会固步自封，止步不前，只停留在同一层思想到老，是很可悲的一件事。学习不仅可以使我们获得前人宝贵的经验，也可以让我们规避他们所犯过的错误，所谓以史明鉴。</p>
<p>现在的我们工作是为了获取原始的积累，只有足够的原始积累，你才能有资本去做你想做的事情。现在你努力工作是为了更好的明天。别抱怨工作，学会去接受它、喜欢它，或许你也可以在工作上实现你人生的价值。</p>
<h2 id="3、构建适合自己的投资逻辑"><a href="#3、构建适合自己的投资逻辑" class="headerlink" title="3、构建适合自己的投资逻辑"></a>3、构建适合自己的投资逻辑</h2><p>投资的门派很多，根据金融市场不同可以分为一级市场的PE、VC，和二级市场流通市场；根据产品的不同可以分为债券、股票、汇率、期权、期货等派别；按照投资行为又分为投资者、投机者、套利者。在这纷扰繁杂的金融市场中，要构建属于自己的投资逻辑，形成自己的投资理念，否则随波逐流投机赚的钱，总又一天会以同样的形式流出。</p>
<h2 id="4、付诸实践，不断试错"><a href="#4、付诸实践，不断试错" class="headerlink" title="4、付诸实践，不断试错"></a>4、付诸实践，不断试错</h2><p>有人说，“年轻人要用于去尝试，不要害怕出错；到老了，犯错误的成本就会很高”。这句话是很有道理的，尤其是在投资界。年轻时，你的资本比较小，亏损了大不了，你还可以重新来过，你还年轻，还有大把的时间可以奋斗，但是当你老了，你已经没有能力或者精力去靠工作赚钱，这时候投资发生损失对于老年生活质量会大大打个折扣。所以，趁年轻，不断去试错，从失败中汲起教训，要么早点认清自己不适合投资，将时间放在更有价值、更合适的地方；要么坚持下去，不断修正自己的投资，完善投资框架，体验投资给你带来的财富增值。</p>
<p>附我的股票投资逻辑图：<br><img src="/2020/03/15/%E6%8A%95%E8%B5%84/invest.jpg" alt="逻辑图"></p>
]]></content>
      <categories>
        <category>感悟</category>
      </categories>
      <tags>
        <tag>股市</tag>
        <tag>想法</tag>
      </tags>
  </entry>
  <entry>
    <title>关于股市的一些看法</title>
    <url>/2020/03/12/%E7%96%AB%E6%83%85-%E8%82%A1%E5%B8%82/</url>
    <content><![CDATA[<p>做坚定的价值投资者</p>
<p>最近，金融市场不太平。由于疫情影响，全球股市暴跌，债券、黄金、石油、期货期权一片低迷，截止到今日，美股更是触发两次熔断，恐慌指数维持在20以上。一时间，整个金融市场一遍哀嚎，空者的天堂，多者的地狱。正可谓风水轮流转，美股结束长达十几年的牛市，跌幅超过20%只用了短短两个星期。</p>
<a id="more"></a>
<p>虽然中国的疫情基本上整体得到控制，但是由于中国市场与全球经济的联动越发密切，A股不可避免地随全球指数暴跌。笔者的账户从原先20%的盈利大幅回撤到5%，或许可能把盈利给抹平。但是，我想说要做坚定的价值投资者。巴菲特曾说过，要在别人贪婪的时候恐惧，恐惧的时候贪婪。前半部分，我自问没有做到，在前段时间A股技术型牛市时候，忽视国外疫情的发展，没有意识到风险，因此现在能做的只有后者。上证指数在3000点附近徘徊，有可能会继续下跌，但整体风险已经减弱，等到国外疫情稳定下来，就是A股突破的日子。</p>
<p>为什么要做坚定的价值投资者呢，纵观A股历史，只有白马股才能穿越牛熊。我们需要做只有不断丰富自己的知识、提高自己的投资水平，发现被低谷的白马股。</p>
]]></content>
      <categories>
        <category>感悟</category>
      </categories>
      <tags>
        <tag>股市</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习-转</title>
    <url>/2020/03/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E8%BD%AC/</url>
    <content><![CDATA[<p>机器学习是计算机科学的一个子领域，在人工智能领域，机器学习逐渐发展成模式识别和计算科学理论的研究。从2016年起，机器学习到达了不合理的火热巅峰。但是，有效的机器学习是困难的，因为机器学习本身就是一个交叉学科，没有科学的方法及一定的积累很难入门。</p>
<a id="more"></a>
<h2 id="一．机器学习入门篇："><a href="#一．机器学习入门篇：" class="headerlink" title="一．机器学习入门篇："></a>一．机器学习入门篇：</h2><p>1、<a href="https://yq.aliyun.com/articles/67218?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">让你少走弯路：这有一份开展机器学习的简短指南</a></p>
<p>摘要：本文分享了一份简单的关于开展机器学习的心得体会，目的是给初学者提供基本的指导，主要讲解了建立系统、选择合适的评价指标、数据处理、系统优化等内容，帮助初学者少走一些弯路。</p>
<p>2、<a href="https://yq.aliyun.com/articles/204352?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">机器学习的入门“秘籍”</a></p>
<p>摘要：机器学习已经成为当下最火热的技术之一，对于初学者来说，如何快速入门机器学习是至关重要的。本文属于入门级宝典，高手请绕道！</p>
<p>3、<a href="https://yq.aliyun.com/articles/213634?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">会玩超级玛丽，机器学习能有多难?</a></p>
<p>摘要：小白也能看懂机器学习？这篇文章用超级玛丽的原理教会你，到底什么是机器学习，让尖端科技不再艰深难懂。</p>
<p>4、<a href="https://yq.aliyun.com/articles/168744?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">机器学习能为你的业务做什么？有些事情你肯定猜不到！第一篇</a></p>
<p>摘要：机器学习是一项令人难以置信的技术，你需要了解很多很多的基础知识，以使得业务功能尽可能的不受复杂算法的影响，让你能够提出正确的问题、了解机器学习模型开发过程、成立一个团队以促进学科间的不断合作，而不是把数据科学视为一个产生奇迹的黑匣子。</p>
<p>5、<a href="https://yq.aliyun.com/articles/169190?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">关于机器学习算法 你需要了解的东西 第二篇</a></p>
<p>摘要：对学习算法进行分类是基于构建模型时所需的数据：数据是否需要包括输入和输出或仅仅是输入，需要多少个数据点以及何时收集数据。根据上述分类原则，可以分为4个主要的类别：监督学习、无监督学习、半监督学习和强化学习。</p>
<p>6、<a href="https://yq.aliyun.com/articles/174724?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">如何开发机器学习模型？第三篇</a></p>
<p>摘要：创建一个优秀的机器学习模型跟创建其他产品是一样的：首先从构思开始，把要解决的问题和一些潜在的解决方案放在一起考虑。一旦有了明确的方向，就可以对解决方案进行原型化，然后对它进行测试以确定是否满足需求，不妨看看本文是如何一步一步实现的。</p>
<p>7、<a href="https://yq.aliyun.com/articles/175707?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">如何高效运作机器学习团队第四篇</a></p>
<p>摘要: 一个“传统”的产品团队由设计师、工程师和产品经理组成，而数据分析师有时也会包含在其中，但大多数情况下是多个团队共享这个稀缺资源。在机器学习团队中又会有哪些角色和组织结构呢，本文为你揭晓。</p>
<p>8、<a href="https://yq.aliyun.com/articles/178357?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">机器学习会产生哪些用户体验问题？第五篇</a></p>
<p>摘要：许多机器学习算法都是黑匣子：输入大量的数据，然后获得一个以某种神秘方式工作的模型。这使得很难向用户解释机器学习的结果。在许多算法中，还存在着交互效应，这使得模型更加难以解释了。你可以把这个看成是特征之间的复合效应，特征之间以多种奇怪而又复杂并且不为人类所理解的方式结合在一起，整体效应大于各个部分效应。</p>
<p>9、<a href="https://yq.aliyun.com/articles/67165?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">简单自学机器学习理论——引言 (Part I)</a></p>
<p>摘要：本篇文章是”机器学习理论”三部曲中的第一部分，主要介绍学习机器学习的动机及基本理论知识，详细介绍机器学习所学习的问题、泛化误差以及学习问题是否可解的公式化表示，为初步研究机器学习的人员介绍了机器学习的基本处理过程。</p>
<p>10、<a href="https://yq.aliyun.com/articles/67168?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">简单自学机器学习理论—— 泛化界限 (Part II )</a></p>
<p>摘要：本篇文章是”机器学习理论”三部曲中的第二部分，主要介绍独立同分布、大数法则及hoeffding不等式等基本数学知识，详细推导了泛化界限及其分解。</p>
<p>11、<a href="https://yq.aliyun.com/articles/67170?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">简单自学机器学习理论——正则化和偏置方差的权衡 (Part III )</a></p>
<p>摘要：本篇文章是”机器学习理论”三部曲中的第三部分，主要介绍方差分解以及目标函数的正则化，通过仿真可以看到，引入正则化项限定了学习问题的解决方案范围。</p>
<p>12、<a href="https://yq.aliyun.com/articles/78023?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">入门级攻略：机器学习 VS. 深度学习</a></p>
<p>摘要：本文以浅显易懂的语言介绍了机器学习和深度学习的定义及应用，以及在源数据要求，硬件支持，特征工程、问题解决方式、执行时间及可解释性等方面的区别，对于新手入门有很大启示意义。</p>
<p>13、<a href="https://yq.aliyun.com/articles/200980?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">增强学习小白？本文带你入门了解增强学习</a></p>
<p>摘要：入门一件新事物总是会有些无从下手的，看了本文希望可以给大家一些帮助和了解。</p>
<p>14、<a href="https://yq.aliyun.com/articles/66489?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">这10本由浅入深的好书，或让你成为机器学习领域的专家</a></p>
<p>摘要：机器学习是个跨领域的学科，而且在实际应用中有巨大作用，但是没有一本书能让你成为机器学习的专家。在这篇文章中，我挑选了10本书，这些书有不同的风格，主题也不尽相同，出版时间也不一样。因此，无论你是新手还是领域专家，定能找到适合你的。</p>
<p>15、<a href="https://yq.aliyun.com/articles/64929?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">想知道机器学习掌握的怎么样了吗？这有一份自测题（附答案和解析）</a></p>
<p>摘要：人类对于自动化和智能化的追求一直推动着技术的进步，而机器学习这类型的技术对各个领域都起到了巨大的作用。随着时间的推移我们将看到机器学习无处不在从移动个人助理到电子商务网站的推荐系统。即使作为一个外行你也不能忽视机器学习对你生活的影响。本次测试时面向对机器学习有一定了解的人。</p>
<p>16、<a href="https://yq.aliyun.com/articles/222864?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">送机器学习电子书——(TensorFlow)RNN入门</a></p>
<p>摘要：本文作者正在写自己的新书Machine Learning with TensorFlow，这篇博文只是他新书的一小部分，作者用简单的语言介绍了RNN，不用一个小例子介绍了如何使用Tensorflow中内置的RNN模型进行预测。</p>
<p>17、<a href="https://yq.aliyun.com/articles/221708?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">适合入门的8个趣味机器学习项目</a></p>
<p>摘要：还在为找不到机器学习入门练手项目而感到无奈吗？本指南中，将给大家带来8个适合初学者学习的有趣的机器学习项目，简单易学，相信会增添大家学习机器学习的信心。</p>
<p>18、<a href="https://yq.aliyun.com/articles/222434?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">机器学习快速入门：你必须知道的三大算法</a></p>
<p>摘要：每天霸占新闻头条的“机器学习”，想入门，先看懂这三大算法。</p>
<h2 id="二．机器学习算法篇："><a href="#二．机器学习算法篇：" class="headerlink" title="二．机器学习算法篇："></a>二．机器学习算法篇：</h2><p>1、<a href="https://yq.aliyun.com/articles/86632?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">快速选择合适的机器学习算法</a></p>
<p>摘要：机器学习初学者可以通过本文了解如何快速找到合适的机器学习算法。</p>
<p>2、<a href="https://yq.aliyun.com/articles/64245?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">多重角度解读：贝叶斯推理是怎么工作的</a></p>
<p>摘要：本文首先介绍了贝叶斯的起源，并利用简单的例子生动形象地讲解了贝叶斯定理是如何工作的，解释了其基本原理以及公式的物理含义。</p>
<p>3、<a href="https://yq.aliyun.com/articles/113512?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">简单通俗易懂：一个小例子完美解释Naive Bayes（朴素贝叶斯）分类器</a></p>
<p>摘要：Naive Bayes分类器的解释有很多，但是基于一个小例子来解释的不多，本文就是基于一个简单通俗易懂的小例子来解释Naive Bayes分类器。</p>
<p>4、<a href="https://yq.aliyun.com/articles/113511?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">“学”、“习”二合一：监督学习——支持向量机（SVM）入门</a></p>
<p>摘要：SVM是机器学习中有监督学习的一种，通常用来进行模式识别、分类、以及回归分析。本文用一个小例子简介SVM，言简意赅，通俗易懂。</p>
<p>5、<a href="https://yq.aliyun.com/articles/214305?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">机器学习利器——决策树和随机森林</a></p>
<p>摘要: 机器学习是当下最火的领域，本文通过一个小例子介绍了其核心算法：决策树和随机森林。</p>
<p>6、<a href="https://yq.aliyun.com/articles/63053?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">基于图的机器算法 （一）</a></p>
<p>摘要：基于图的机器算法学习是一个强大的工具。结合运用模块特性，能够在集合检测中发挥更大作用。</p>
<p>7、<a href="https://yq.aliyun.com/articles/65036?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">基于图的机器算法 （二）</a></p>
<p>摘要：基于图的机器算法学习是一个强大的工具。结合运用模块特性，能够在集合检测中发挥更大作用。本文是基于图的机器算法系列文的第二篇。</p>
<p>8、<a href="https://yq.aliyun.com/articles/66987?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">简单易学！一步步带你理解机器学习算法——马尔可夫链蒙特卡罗（MCMC）</a></p>
<p>摘要：对于简单的分布，很多的编程语言都能实现。但对于复杂的分布，是不容易直接抽样的。马尔可夫链蒙特卡罗算法解决了不能通过简单抽样算法进行抽样的问题，是一种实用性很强的抽样算法。本文将简明清晰地讲解马尔可夫链蒙特卡罗算法，带你理解它。</p>
<p>9、<a href="https://yq.aliyun.com/articles/66794?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">进阶隐式矩阵分解——探讨如何实现更快的算法</a></p>
<p>摘要：本文重点是围绕Conjugate Gradient（共轭梯度）方法来探讨更优的矩阵分解算法。</p>
<p>10、<a href="https://yq.aliyun.com/articles/73484?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">纯干货|机器学习中梯度下降法的分类及对比分析（附源码）</a></p>
<p>摘要：本文详细介绍了基于使用数据量的多少，时间复杂度以及算法准确率的不同类型的梯度下降法，并详细说明了3种梯度下降法的比较。</p>
<p>11、<a href="https://yq.aliyun.com/articles/68901?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">深度学习网络大杀器之Dropout（I）——深入解析Dropout</a></p>
<p>摘要：本文详细介绍了深度学习中dropout技巧的思想，分析了Dropout以及Inverted Dropout两个版本，另外将单个神经元与伯努利随机变量相联系让人耳目一新。</p>
<p>12、<a href="https://yq.aliyun.com/articles/110002?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">深度学习网络大杀器之Dropout（II）——将丢弃学习视为集成学习之我见</a></p>
<p>摘要：本文分析了可以将丢弃学习当作是集成学习。在集成学习中，可以将一个网络划分成若干个子网络，并且单独训练每个子网络。在训练学习后，将每个子网络的输出进行平均得到集成输出。另外，展示了丢弃学习可以看成是在每次迭代中不同隐藏节点集合的集成学习表现，同时也展示了丢弃学习有着与L2正则化一样的效果。</p>
<p>13、<a href="https://yq.aliyun.com/articles/73661?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">神经网络常用激活函数对比：sigmoid VS sofmax（附python源码）</a></p>
<p>摘要：本文介绍了神经网络中的两种常用激活函数——softmax与sigmoid函数，简单介绍了其基本原理、性质及其使用，并用python进行了实例化演示，在文章的最后总结了两种激活函数的区别。</p>
<p>14、<a href="https://yq.aliyun.com/articles/72738?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">新颖训练方法——用迭代投影算法训练神经网络</a></p>
<p>摘要：本文介绍了一种利用迭代投影算法对神经网络进行训练的方法，首先介绍了交替投影的基础知识，说明投影方法是寻找非凸优化问题解决方案的一种有效方法；之后介绍了差异图的基础知识，将差异图与一些其他算法相结合使得差分映射算法能够收敛于一个好的解决方案；当投影的情况变多时，介绍了分治算法，最后将迭代投影算法应用到神经网络训练中，给出的例子实验结果表明效果不错。</p>
<p>15、<a href="https://yq.aliyun.com/articles/71662?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">车辆追踪算法大PK：SVM+HOG vs. YOLO</a></p>
<p>摘要：本文通过SVM+HOG算法，YOLO算法实现车辆检测和跟踪准确性和速度的对比，得出YOLO算法更具优势的结论。</p>
<p>16、<a href="https://yq.aliyun.com/articles/69263?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">什么是视频向量化？本文带你了解基于DeepWalk的视频推荐</a></p>
<p>摘要：本文简要讲述了视频向量化，对DeepWalk的算法进行简单的解释。</p>
<p>17、<a href="https://yq.aliyun.com/articles/70733?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">比PCA降维更高级——（R/Python）t-SNE聚类算法实践指南</a></p>
<p>摘要: 本文介绍t-SNE聚类算法，分析其基本原理。并从精度上与PCA等其它降维算法进行比较分析，结果表明t-SNE算法更优越，本文最后给出了R、Python实现的示例以及常见问题。t-SNE算法用于自然语音处理、图像处理等领域很有研究前景。</p>
<p>18、<a href="https://yq.aliyun.com/articles/216164?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">随机森林 VS 梯度提升机——模型融合之我见</a></p>
<p>摘要：本文节选自Quora社区上“When would one use Random Forests over Gradient Boosted Machines (GBMs)?”问题的回答，几位博主就随机森林(Random Forests)与梯度提升机(Gradient Boosted Machines, GBMs)的适合场景以及优缺点展开了讨论。</p>
<h2 id="三．机器学习常用库："><a href="#三．机器学习常用库：" class="headerlink" title="三．机器学习常用库："></a>三．机器学习常用库：</h2><p>1、<a href="https://yq.aliyun.com/articles/69330?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">倚天遇到屠龙：LightGBM VS xgboost谁才是最强的梯度提升库？</a></p>
<p>摘要：很多人把XGBoost比作屠龙刀，LightGBM比作倚天剑，那么当倚天遇到屠龙，谁更强呢？</p>
<p>2、<a href="https://yq.aliyun.com/articles/81469?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">即学即用：Pandas入门与时间序列分析</a></p>
<p>摘要：这篇文章是Alexander Hendorf 在PyData Florence 2017上做的报告。报告前半部分主要为初学者介绍Pandas的基本功能，如数据输入/输出、可视化、聚合与选择与访问，后半部分主要介绍如何使用Pandas进行时间序列分析，源代码亲测可用。</p>
<p>3、<a href="https://yq.aliyun.com/articles/136493?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">俄罗斯最大搜索引擎Yandex开源了一款梯度提升机器学习库CatBoost</a></p>
<p>摘要：俄罗斯搜索巨头Yandex宣布，将向开源社区提交一款梯度提升机器学习库CatBoost。它能够在数据稀疏的情况下“教”机器学习。特别是在没有像视频、文本、图像这类感官型数据的时候，CatBoost也能根据事务型数据或历史数据进行操作。</p>
<p>4、<a href="https://yq.aliyun.com/articles/159746?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">Netflix开源面向稀疏数据优化的轻量级神经网络库Vectorflow</a></p>
<p>摘要：在Netflix公司，我们的机器学习科学家在多个不同的领域处理着各种各样的问题：从根据你的爱好来定制电视和推荐电影，到优化编码算法。我们有一小部分问题涉及到处理极其稀疏的数据；手头问题的总维度数很容易就能达到数千万个特征，即使每次要看的可能只是少数的非零项。</p>
<p>5、<a href="https://yq.aliyun.com/articles/210393?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">Python高性能计算库——Numba</a></p>
<p>摘要：在计算能力为王的时代，具有高性能计算的库正在被广泛大家应用于处理大数据。例如：Numpy，本文介绍了一个新的Python库——Numba， 在计算性能方面，它比Numpy表现的更好。</p>
<p>6、<a href="https://yq.aliyun.com/articles/68270?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">第二热门语言：从入门到精通，Python数据分析库大全</a><br>摘要：本文介绍了一些常见的用于数据分析任务的Python库，如Numpy、Pandas、Matplotlib、Scikit-learn以及BeautifulSoup等，这些工具库功能强大，便于上手。有了这些帮助，数据分析会变得分外简单。</p>
<p>7、<a href="https://yq.aliyun.com/articles/158384?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">新工具——TensorLayer：管理深度学习项目的复杂性</a></p>
<p>摘要：本文介绍了一种新基于TensorFlow的python库——TensorLayer，它能够有效的帮助开发者管理好自己的深度学习网络。并且它还提供了很多功能强悍的API，帮助开发者更好的完成任务。</p>
<p>8、<a href="https://yq.aliyun.com/articles/215295?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">Pandas并非完美无缺</a></p>
<p>摘要：我们一直使用Pandas，但是却不知道关于Pandas的细节。Pandas开发者深度复盘Pandas，指出了十大关键性问题，并通过介绍了如何使用Apache Arrow来解决这些问题。</p>
<p>9、<a href="https://yq.aliyun.com/articles/222523?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">关于Numba你可能不了解的七个方面</a></p>
<p>摘要：目前Numba正被开始流行使用来加速Python程序，本文讲解了七个大家可能不了解的方面，希望对大家有所帮助。</p>
<h2 id="四．机器学习实战篇："><a href="#四．机器学习实战篇：" class="headerlink" title="四．机器学习实战篇："></a>四．机器学习实战篇：</h2><p>1.57行价值八千万美元的车牌识别代码</p>
<p>摘要：为了防止被窃车辆进入黑市销售，警方使用了一个名为VicRoads的基于网络的服务，该服务用于检查车辆的登记状态。该警局还投资研发了一个固定式汽车牌照扫描器：一个固定的三脚架摄像头，可扫描过往的车辆，并自动识别被窃车辆。</p>
<p>2.如何利用机器学习预测房价？</p>
<p>摘要：本文作者利用自己过去三个月里所学到的东西，来预测所在城市的房价。所用到的技术有网络爬取技术、文本自然语言处理，图像上的深度学习模型以及梯度增强技术等。</p>
<p>3.机器学习中的技术债务</p>
<p>摘要：许多人遇到技术债务时都会眉头紧锁，但一般来说，技术债务并不是一件坏事。例如，当我们需要在最后期限之前发布版本的时候，技术债务就是一个可以利用起来的合理手段。但是技术债务存在与金融债务一样的问题，那就是到了要偿还债务的时候，我们所付出的要比开始时付出得多。这是因为技术债务具有复合效应。</p>
<p>4.DIY图像压缩——机器学习实战之K-means 聚类图像压缩：色彩量化</p>
<p>摘要：本文以图像压缩为例，介绍了机器学习的实际应用之一。</p>
<p>5.如何将机器学习用在基于规则的验证上</p>
<p>摘要：这篇文章介绍了一些高级问题，比如：智能自治系统的验证有多少可以用机器学习来实现？大多数的需求是否仍然是基于规则的，如果是这样，那么它们如何跟机器学习相结合？ 机器学习和规则之间的不稳定接口如何影响基于机器学习的系统？</p>
<p>6.Certigrad——随机计算图优化系统</p>
<p>摘要：Certigrad是一种概念证明，它是用于开发机器学习系统的一个新途径。</p>
<p>7.使用神经网络和遗传算法玩转 Flappy Bird</p>
<p>摘要：本文展示了针对Flappy Bird游戏设计的机器学习算法。本实验的目标是使用神经网络和遗传算法编写一个人工智能游戏控制器，打出游戏最高分，不服的来挑战！</p>
<p>8.教机器写代码：增强拓扑进化网络(NEAT)</p>
<p>摘要：NEAT的意思是“增强拓扑进化网络”，它描述了在进化过程中受遗传修饰启发的自学习机器的算法概念，不妨看看它是如何教机器写代码的。</p>
<ol>
<li>机器学习中，使用Scikit-Learn简单处理文本数据</li>
</ol>
<p>摘要：机器学习中，我们总是要先将源数据处理成符合模型算法输入的形式，比如将文字、声音、图像转化成矩阵。对于文本数据首先要进行分词（tokenization），移除停止词（stop words），然后将词语转化成矩阵形式，然后再输入机器学习模型中，这个过程称为特征提取（feature extraction）或者向量化（vectorization）。</p>
<h2 id="五．机器学习杂谈篇："><a href="#五．机器学习杂谈篇：" class="headerlink" title="五．机器学习杂谈篇："></a>五．机器学习杂谈篇：</h2><p>1.关于机器学习你必须了解的十个真相</p>
<p>摘要：作者从非专业人士的角度对人工智能常见的误解进行了解释说明。</p>
<p>2.谁更胜一筹？——随机搜索 V.S. 网格搜索</p>
<p>摘要：随机法和网格法都是常用的、有效的结构优化方法。那么它们两者当中谁更胜一筹呢？在本文中，作者通过有趣的地形搜索实验，找到了答案。</p>
<p>3.没有任何公式——直观的理解变分自动编码器VAE</p>
<p>摘要：本文简单介绍了变分自动编码器VAE的基本原理，从经典神经网络的贝叶斯计算概率方法慢慢转变到变分自动编码器神经网络中的优化问题，使用KL散度度量误差，给大家提供一个VAE的基本框架。全篇没有公式，通俗易懂。</p>
<p>4.增强避障系统设计浅析：站在机器学习的角度，剖析学习型避障小车的设计思路</p>
<p>摘要：FF91于12017年1月4日在美国拉斯维加斯成功首发，拉开了互联网生态电动汽车的序幕。自动泊车使得停车也成为了一种享受，新手司机再也不用担心该如何见缝插针了。但是如果在车水马龙的繁忙环境下，无人驾驶还能得心应手吗？本文将站在机器学习的角度和大家分享学习型避障小车的设计思路。</p>
<p>5.AlphaGo在围棋界成为最强王者后，我们该如何进行机器学习？</p>
<p>摘要：机器学习无疑是时下的科技热点。无人驾驶，机器下棋，股市预测等领域，我们都能找到机器学习忙碌和高大的身影。那么对于初学者来说，该如何下手？该怎么学习呢？</p>
<p>6.分享Andrew Ng在深度学习暑期班中演讲的机器学习项目</p>
<p>摘要：深度学习项目流程，带你走出迷茫。</p>
<p>7.分布式机器学习平台比较</p>
<p>摘要：机器学习，特别是深度学习（DL），最近已经在语音识别、图像识别、自然语言处理、推荐/搜索引擎等领域获得了成功。这些技术在自主驾驶汽车、数字卫生系统、CRM、广告、物联网等方面都存在着非常有前景的应用。当然，资金驱动着这些技术以极快的速度向前发展，而且，最近我们已经看到了有很多机器学习平台正在建立起来。</p>
<p>8.<a href="https://yq.aliyun.com/articles/187541?spm=a2c4e.11153940.0.0.a9c92664Gi6jmF" target="_blank" rel="noopener">机器学习和统计学的“爱恨情仇”可以结束了</a></p>
<p>摘要：机器学习和统计学在数据科学的领域里，已经相爱相杀很多年。今天，就让我们跟随ML从业者和统计学家两者组成团队，解开两者这几十年的“爱恨情仇”。</p>
<p>9.2017上半年无监督特征学习研究成果汇总</p>
<p>摘要：无监督学习是人工智能时代核心技术，今天我们就来盘点一下2017上半年无监督学习出现了那些重要的研究成果。</p>
<p>10.有监督相似性学习：基于相似问题数据的对称关系学习</p>
<p>摘要：本文简单介绍基于相似问题数据的对称关系学习，通过在Quora数据集和StackExchange语料库上应用孪生卷积神经网络的结果表明，对称网络能够较大幅度地提高检测精度。</p>
<p><strong>11.应用机器学习：传道解惑指南</strong></p>
<p>摘要：本文作者编辑了一份包括概念、定义、资源以及工具的知识合集，这对于在这个复杂领域从事工作的人来说非常有用。</p>
<p><a href="https://yq.aliyun.com/articles/221644?utm_content=m_33134" target="_blank" rel="noopener">本文原址</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>转发</tag>
      </tags>
  </entry>
  <entry>
    <title>FRM-之信用风险管理</title>
    <url>/2020/03/03/FRM-%E4%B9%8B%E4%BF%A1%E7%94%A8%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p><strong>信用风险管理笔记</strong></p>
<h2 id="信用决定"><a href="#信用决定" class="headerlink" title="信用决定"></a>信用决定</h2><p>the probability of Default(PD)，the loss given default(LGD)，the exposure at default(EAD)<br>the overall expected loss(EL)<br>expected loss(EL) = PD <em> LGD </em> EL<br>Time horizon：时间窗口</p>
<p>交易风险：</p>
<ul>
<li>settlement risk 交割风险</li>
<li>financial obligation </li>
</ul>
<p>分析方法：</p>
<ul>
<li>定性分析：sovereign risk ratings</li>
<li>定量分析：historical nature of the data</li>
</ul>
<a id="more"></a>
<h2 id="信用分析"><a href="#信用分析" class="headerlink" title="信用分析"></a>信用分析</h2><h2 id="信用风险的分类和主要概念"><a href="#信用风险的分类和主要概念" class="headerlink" title="信用风险的分类和主要概念"></a>信用风险的分类和主要概念</h2><h2 id="评估方法"><a href="#评估方法" class="headerlink" title="评估方法"></a>评估方法</h2><h2 id="信用风险和信用衍生品"><a href="#信用风险和信用衍生品" class="headerlink" title="信用风险和信用衍生品"></a>信用风险和信用衍生品</h2><h2 id="结构信用风险"><a href="#结构信用风险" class="headerlink" title="结构信用风险"></a>结构信用风险</h2><h2 id="对手方风险"><a href="#对手方风险" class="headerlink" title="对手方风险"></a>对手方风险</h2><h2 id><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
      <categories>
        <category>FRM二级</category>
      </categories>
      <tags>
        <tag>FRM</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/03/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<a id="more"></a>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>Hello World</category>
      </categories>
      <tags>
        <tag>hello</tag>
      </tags>
  </entry>
</search>
