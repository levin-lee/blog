<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/03/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <tags>
        <tag>hello</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 指令大全</title>
    <url>/2020/03/01/Linux-%E6%8C%87%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<h2 id="一，注销，关机，重启"><a href="#一，注销，关机，重启" class="headerlink" title="一，注销，关机，重启"></a>一，注销，关机，重启</h2><ul>
<li>1、Logout 注销是登陆的相对操作，登陆系统后，若要离开系统，用户只要直接下达<br>logout 命令即可：</li>
<li>2、关机或重新启动的 shutdown 命令：<br>  －h 参数让系统立即关机<pre><code>shutdown –h now ← 要求系统立即关机；
shutdown now ← 立刻关机；
shutdown +5 ← 5 分钟后关机；
shutdown 10:30 ← 在 10：30 时关机；</code></pre>  －r 参数设置关机后重新启动<pre><code>shutdown -r now ← 立刻关闭系统并重启；
shutdown -r 23:59 ← 指定在 23：59 时重启动；</code></pre></li>
<li>3、重新启动计算机的 reboot 命令：<br>   -f 参数：不依正常的程序运行关机，直接关闭系统并重新启动计算机；<br>   -I 参数：在在重新启动之前关闭所有网络接口；<br>   虽然 reboot 命令有个参数可以使用，但是一般只需要单独运行 reboot 命令就可以了<h2 id="二，文件与目录的操作"><a href="#二，文件与目录的操作" class="headerlink" title="二，文件与目录的操作"></a>二，文件与目录的操作</h2></li>
<li>1、列出文件列表的 ls 命令<br>  ls：显示当前目录的内容；<br>  ls –a： 当运行 ls 命令时，并不会显示名称以“.”开头的文件。因此可加上“-a”参数指<br>定要列出这些文件；<br>  ls –s –S：以“-s”参数显示每个文件所有的空间，并以“-S”参数指定按所有占用空间的大<br>小排序；<br>  ls –l/usr/games：在 ls 命令后直接加上欲显示的目录路径，就会列出该目录的内容；</li>
<li>2、切换目录的 cd 命令<br>   cd tony ← 切换到当前目录下的 tony 子目录；<br>   cd .. ← 切换到上一层目录；<br>   cd / ← 切换到系统根目录；<br>   cd /usr/bin ← 切换到/usr/bin 目；</li>
<li>3、创建目录的 mkdir 命令<br>   mkdir tool：在目录下创建 tool 子目录</li>
<li>4、删除目录的 rmdir 命令<br>   rmdir tool ← 删除 tool 目录</li>
<li>5、复制文件的 cp 命令<br>   cp data1.txt data2.txt ← 将 data1.txt 复制成 data2.txt；<br>   cp data3.txt /tmp/data ← 将 data3 复制到/tmp/data 目录中；<br>  加入-v 参数可显示命令执行过程：<pre><code>cp zip.txt zip2.txt ← 一般状态下不会显示复制过程；
cp –v zip.txt zip3.txt ← 以-v 显示复制过程；</code></pre>  加入“-R”参数可同时复制目录下的所有文件及子目录：<pre><code>cp –v –R * backup ← 将所有文件（含子目录文件）复制到 backup 目录</code></pre></li>
<li>6、删除文件或目录的 rm 命令<pre><code>rm myfile ← 删除指定的文件；
rm * ← 删除当前目录中的所有文件；</code></pre>  使用-f 参数时，rm 命令会直接删除文件，不再询问：<pre><code>rm –f *.txt ← 强迫删除文件；</code></pre>  -r 也是一个相当常用的参数，使用此参数可同时删除指定目录下的所有文件及子目录<pre><code>rm –r data ← 删除 data 目录（含 data 目录下所有文件和子目录）；
rm –r * ← 删除所有文件（含当前目录所有文件，所有子目录和子目录下的文件）</code></pre>  使用-rf 参数，系统将直接删除该目录中所有的文件及子目录，不再询问。<pre><code>rm –rf tmp 强制删除 tmp 目录及该目录下所有文件及子目录；</code></pre></li>
<li>7、让显示画面暂停的 more 命令<pre><code>ls –al more：当使用 ls 命令查看文件列表时，若文件太多则可以配合 more 命令使用；
more data.txt： 单独使用 more 命令时，可用来显示文字文件的内容；</code></pre></li>
<li>8、连接文件的 cat 命令<br>  cat命令可以显示文件的内容（经常和 more 命令搭配使用），或是将数个文件合并成一个文件<pre><code>cat preface.txt more：逐页显示 preface.txt 的内容；
cat preface.txt &gt;&gt; outline.txt： preface.txt 附加到 outline.txt 文件之后；
cat new.txt info.txt &gt;readme.txt：将 new.txt 和 info.txt 合并成 readme.txt 文件</code></pre>  一次显示整个文件：<pre><code>cat filename</code></pre></li>
<li>9、移动或更换文件，目录名称的 mv 命令<br>  mv（move）命令可以将文件及目录移动到另一个目录下面，或更换文件及目录的名称<pre><code>mv a.txt .. ← 将 a.txt 文件移到上层目录
mv z1.txt z3.txt ← 将 z1.txt 改名成 z3.txt
 cd.. ← 切换到上一层目录
mv backup.. ← backup 目录上移一层</code></pre></li>
<li>10、显示当前所在目录的 pwd 命令<br>  pwd(print working directory)命令可显示用户当前所在的目录</li>
<li>11、查找文件的 locate 命令<br>  locate 命令可用来搜索包含指定条件字符串的文件或目录<pre><code>locate zh_CN 列出所有包含“zh_CN”字符串的文件和目录</code></pre></li>
<li>12、搜索字符串得 grep 命令<br>  grep 命令可以搜索特定字符串来并显示出来<pre><code> grep text *.conf ← 搜索当前目录中扩展名为.conf 且包含“text”字符串；
grep:amd.conf: ← 拒绝不符权限得操作；
grep:diskcheck.conf: ← 拒绝不符权限得操作；
grep:grub.conf ← 拒绝不符权限得操作；
grep –s text *.conf：拒绝不符权限的操作之类的错误信息，可使用-s 参数消除</code></pre></li>
<li>13、重导与管道<br>  “&gt;”可将结果输出到文件中，该文件原有的内容会被删除：“&gt;&gt;”则将结果附加到文件中，原文件内容不<br>会被清除<pre><code>ls –a&gt;dir.txt ← 将 ls –a 命令执行结果输出到 dir.txt 文件；
cat data1.txt &gt;&gt; data2.txt ← 将 data1.txt 内容附加到 data2.txt 文件之后。</code></pre>  通道(pipe)命令的符号是“ ”，可将某命令的结果输出给另一命令<pre><code>ls gerp conf ← 搜索并显示 ls 命令运行结果中包含有“conf”字符串；
yes rm –r mydir：在删除文件或目录的时，可以利用 yes 命令重复输出“y”字符的特性，将结果传给 rm</code></pre>命令，如此即可避免重复输入“y”</li>
<li>14、Linux文件内容查看</li>
</ul>
<ul>
<li>Cat 由第一行开始显示文件内容</li>
<li>Tac 从文件最后一行开始显示</li>
<li>Nl 显示的时候，顺道输出行号！</li>
<li>more一页一页的显示文件内容</li>
<li>less与more类似，但是比more更好的是，他可以往前翻页</li>
<li>head只看头几行</li>
<li>tail只看尾巴几行<h2 id="三、打包、压缩与解压缩"><a href="#三、打包、压缩与解压缩" class="headerlink" title="三、打包、压缩与解压缩"></a>三、打包、压缩与解压缩</h2></li>
</ul>
<ul>
<li>1、打包文件的 tar 命令<br>tar 命令位于/bin 目录中，它能将用户所指定的文件或目录打包成一个文件<pre><code>-c：创建一个新的 tar 文件；
 -v：显示运作过程信息；
 -f：在：指定文件名称；
 -z：调用 gzip 压缩命令执行压缩；
 -j：调用 bzip2 压缩命令执行压缩；
-t：参看压缩文件内容；
-x：解开 tar 文件
         tar cvf data.tar * ← 将目录下所有文件打包成 data.tar；
         tar cvf data.tar.gz * ← 将目录所有文件打包成 data.tar 再用 gzip 命令压缩；
         tar tvf data.tar * ← 查看 data.tar 文件中包括了哪些文件；
         tar xvf data.tar * ← 将 data.tar 解开</code></pre></li>
<li>2、压缩与解压缩<br>  使用-z 参数来解开最常见的.tar.gz 文件：<pre><code>tar –zxvf foo.tar.gz ←将文件解开至当前目录下</code></pre>  使用-j 参数解开 tar.bz2 压缩文件：<pre><code>tar –jxvf linux-2.4.20tar.bz2 ←将文件解开至当前目录下</code></pre>   使用-Z 参数指定以 compress 命令压缩：<pre><code>tar –cZvf prcture.tar.Z*.tif 将该目录下所有.tif 打包并命令压缩成.tar.Z文件</code></pre><h2 id="四：其他常用命令"><a href="#四：其他常用命令" class="headerlink" title="四：其他常用命令"></a>四：其他常用命令</h2></li>
<li>1、修改密码的 passwd 命令<br>  passwd（password）命令可让用户变更密码</li>
<li>2、创建引导盘的 mkbootdisk 命令<br>  利用 mkbootdisk 命令创建一张新的引导盘：<pre><code>mkbootdisk ‘uname -r</code></pre></li>
<li>3、显示与设置时间的 date、clock 和 ntpdate 命令<br>  date 命令可以显示当前日期时间；<br>  clock 命令也可以显示出系统当前的日期与时间；<pre><code>date 09091200 ← 将时间设定为 9 月 9 日 12 点 00 分；
ntpdate stdtime.microsoft.com ← 与微软校时服务器校时；
clock –w：这样下次启动时才会使用更改过的时间</code></pre></li>
</ul>
<h2 id="环境变量的查看"><a href="#环境变量的查看" class="headerlink" title="环境变量的查看"></a>环境变量的查看</h2><ul>
<li>1、使用echo命令查看单个环境变量。例如：<br>echo $PATH </li>
<li>2、使用env查看所有环境变量。例如：<br>env </li>
<li>3、使用set查看所有本地定义的环境变量</li>
</ul>
<p>杀死正在进行或已经是DEST状态的进程<br>        ps -aux：查看所有进程<br>        sudo kill PID：杀死相对应的PID号码<br>文件查看<br>使用wc命令 具体通过wc –help 可以查看。</p>
<ul>
<li>wc -l filename 就是查看文件里有多少行；</li>
<li>wc -w filename 看文件里有多少个word；</li>
<li>wc -L filename 文件里最长的那一行是多少个字。<br>wc命令<br>　　wc命令的功能为统计指定文件中的字节数、字数、行数, 并将统计结果显示输出。<br>　　语法：wc [选项] 文件…<br>　　wc同时也给出所有指定文件的总统计数。字是由空格字符区分开的最大字符串。该命令各选项含义如下：<br>　　- c 统计字节数。<br>　　- l 统计行数。<br>　　- w 统计字数。<br>　　这些选项可以组合使用。输出列的顺序和数目不受选项的顺序和数目的影响。总是按下述顺序显示并且每项最多一列。<br>　　行数、字数、字节数、文件名<br>　　如果命令行中没有文件名，则输出中不出现文件名。<br>　　例如：<br>　　$ wc - lcw file1 file2<br>　　4 33 file1<br>　　7 52 file2<br>　　11 11 85 total<pre><code>省略任选项-lcw，wc命令的执行结果与上面一样。</code></pre>解压：<pre><code>sudo tar -zxvf pip-6.0.8.tar.gz
cd ~ 返回默认根目录</code></pre>删除文件：<pre><code>rm -f /var/log/httpd/access.log</code></pre>删除文件夹：<pre><code>rm -rf /var/log/httpd/access</code></pre>修改文件：vim<pre><code>退出：先输入冒号 : ，在输入wq
  删除文件第一行：sed -i &apos;1d&apos; ~/923-928/jxjdd_new.csv
  删除文件最后一行：sed -i &apos;$d&apos; ~/923-928/jxjdd_new.csv</code></pre>查看指令：<pre><code>1、date —help
2、man date</code></pre>不用密码登陆：<pre><code> vim .pgpass
之后配置id和端口以及对应的密码</code></pre>分享文件：<pre><code>  python -m SimpleHTTPServer 8123
网址：bjyz-holmes-0014.bjyz.baidu.com:8111</code></pre>查找字符：<pre><code>grep “string” yuqi.csv  * -n --color</code></pre></li>
</ul>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>信贷指标</title>
    <url>/2020/02/26/%E4%BF%A1%E8%B4%B7%E6%8C%87%E6%A0%87/</url>
    <content><![CDATA[<h2 id="1、迁移率。"><a href="#1、迁移率。" class="headerlink" title="1、迁移率。"></a>1、迁移率。</h2><p>迁移率侧重于分析客户状态的发展变化路径，如M0-M1，M1-M2，M2-M3等。</p>
<p>具体含义：</p>
<ul>
<li>M0：没有逾期；</li>
<li>M1：表示逾期1-30天；</li>
<li>M2：表示逾期31-60天；</li>
<li>M3：表示逾期61-90天；</li>
<li>M4：表示逾期91-120天；</li>
<li>M5：表示逾期121-150天；</li>
<li>M6：表示逾期151-180天；</li>
<li>M6+：表示逾期180天以上。<br>迁移率模型：是一种来预测未来坏账损失的方法，它通过对历史数据中处于某一拖欠位置的账户贷款余额每月拖欠变化情况的分析，来预测当期不同拖欠周期的未来坏账损失</li>
</ul>
<h2 id="2、滚动率"><a href="#2、滚动率" class="headerlink" title="2、滚动率"></a>2、滚动率</h2><p>滚动率分析可以对客户好坏程度进行定义。<br>滚动率分析就是从某个观察点之前的一段时间(称为观察期)的最坏的状态向观察点之后的一段时间(称为表现期)的最坏状态的发展变化情况<br> 在风险控制中，我们的根本目的是识别坏用户，通过历史数据，抓取坏客户显著区别于正常客户的特征，并以此为标准去预测未来的坏客户。用户的好坏其实很难定义，不能说逾过期的用户就是坏用户，也许人家其实想还，只是不小心忘记还款了呢。而且，有的时候，“适当”的逾期还能增加公司的逾期利息收入。我们所关注的坏客户是坏到某一程度，也就是逾期等级较高且不还款的客户。</p>
<p>前面说的vintage是从时间维度上判断客户群体的好坏，下面说的滚动率则是从行为程度上判断客户的好坏，它可以帮助我们判断某些逾期客户是否还可以再抢救一下，收回点成本。</p>
<p>滚动率，简单地说就是以某一时间点为观察节点，观察客户在该点前一段时间内（比如半年）最坏逾期阶段，并追踪其在观察点之后的一段时间向其他逾期阶段发展的情况，特别是向更坏程度发展的情况。举个栗子，今天是2018年5月25日，取今天的1万个客户，统计他们在过去半年里的最大逾期阶段。然后追踪他们后半年的表现。以下数字纯属虚构，完全是为了说明问题，各个公司有自己的观察数据和追踪数据。</p>
<pre><code>M0的客户在未来半年里，98%的客户还是会保持正常M0的状态
最大逾期阶段M1的客户在未来80%会变M0，但是还有20%会继续，甚至有5%的人往更坏的程度发展
最大逾期阶段M2的客户在未来40%的人会继续恶化，22%左右的人会变M0（完全从良）；
最大逾期阶段M3的客户在未来60%的人会继续恶化，15%左右的人会变M0（完全从良）；
最大逾期阶段M3+的客户在未来80%的客户会继续此状态（没救了）。

根据以上的数据，我们可能就可以得出逾期3期以上的客户，都是无力抢救的坏客户这样的结论。假如我们想把条件收紧一点，那么我们可能会选择逾3期或者2期。再假如我要给坏设定等级，那么我就可以把3期以上设为极度坏，逾3、2期的话可能设置为中度坏，逾1期的人可以是不经意的坏。这些特征将来可以放到风控建模的样本特征中来。</code></pre><h2 id="3、A卡"><a href="#3、A卡" class="headerlink" title="3、A卡"></a>3、A卡</h2><p>申请：用户会提交相关材料进行审核。这里会使用A卡！A（Application）+配套策略决定是否会放款！<br>A卡（Application score card）申请评分卡<br>贷前！</p>
<h2 id="4、B卡"><a href="#4、B卡" class="headerlink" title="4、B卡"></a>4、B卡</h2><p>放款：贷中使用B（Behavior）卡及策略。<br>B卡（Behavior score card）行为评分卡<br>贷中！</p>
<h2 id="5、C卡"><a href="#5、C卡" class="headerlink" title="5、C卡"></a>5、C卡</h2><p>提醒催收：C（Collection）卡！结果：用户还款或者不还款！<br>C卡（Collection score card）催收评分卡<br>贷后！</p>
]]></content>
      <tags>
        <tag>风控</tag>
      </tags>
  </entry>
  <entry>
    <title>gitlab操作</title>
    <url>/2020/02/26/gitlab%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="命令行指南"><a href="#命令行指南" class="headerlink" title="命令行指南"></a>命令行指南</h2><p>git全局配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;lelingshan01_dxm&quot;</span><br><span class="line">git config --global user.email &quot;lelingshan01@duxiaoman.com&quot;</span><br></pre></td></tr></table></figure>

<h2 id="创建一个新项目"><a href="#创建一个新项目" class="headerlink" title="创建一个新项目"></a>创建一个新项目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone ssh:&#x2F;&#x2F;git@gitlab.duxiaoman-int.com:8022&#x2F;lelingshan01_dxm&#x2F;demo2.git</span><br><span class="line">cd demo2</span><br><span class="line">touch README.md</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;add README&quot;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<h2 id="基于存在的文件夹新建项目"><a href="#基于存在的文件夹新建项目" class="headerlink" title="基于存在的文件夹新建项目"></a>基于存在的文件夹新建项目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd existing_folder</span><br><span class="line">git init</span><br><span class="line">git remote add origin ssh:&#x2F;&#x2F;git@gitlab.duxiaoman-int.com:8022&#x2F;lelingshan01_dxm&#x2F;demo2.git</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;Initial commit&quot;</span><br><span class="line">git push -u origin master</span><br><span class="line">或者 git push origin HEAD:refs&#x2F;for&#x2F;master</span><br></pre></td></tr></table></figure>

<h2 id="基于存在的git仓库新建项目"><a href="#基于存在的git仓库新建项目" class="headerlink" title="基于存在的git仓库新建项目"></a>基于存在的git仓库新建项目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd existing_repo</span><br><span class="line">git remote rename origin old-origin</span><br><span class="line">git remote add origin ssh:&#x2F;&#x2F;git@gitlab.duxiaoman-int.com:8022&#x2F;lelingshan01_dxm&#x2F;demo2.git</span><br><span class="line">git push -u origin --all git push -u origin --tags</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>gitlab</tag>
      </tags>
  </entry>
</search>
